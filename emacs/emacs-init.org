#+Title: My literate Emacs initialisation file
#+Description: My literate emacs initialisation file.
#+Startup: indent

* Introduction

This is my ~emacs~ initialisation code, documented for my own understanding
in the future and for sharing with others.

I'm following [[https://alhassy.github.io/init/][Musa's]] example using an ~org~ file for this.

** Setting up ~.emacs~ to use this code

Create a symbolic link to this file in =~/.emacs.d/~,
then add to the bottom of =~/.emacs= these lines:
#+BEGIN_EXAMPLE emacs-lisp
;; BEGIN my edits

;; I've set up an init file following Musa's guide: https://alhassy.github.io/init/

;; Enable Emacs VC on symlinked files
(setq vc-follow-symlinks t)

;; Evaluate my init file.
(org-babel-load-file "~/.emacs.d/emacs-init.org")

;; Byte compile the file so that changes to emacs-init.org get picked up.
(byte-compile-file "~/.emacs")

;; END my edits
#+END_EXAMPLE

*** Why set ~vc-follow-symlinks~ here?

It's a setting I want anyway (it ensures Emacs's version control
works correctly on the target file), but why set it in ~.emacs~?

Since ~.emacs~ uses a symlink to this version controlled file,
having Emacs prompt me every time is annoying and slows my start up.

* Major packages

** Package repositories

#+begin_src emacs-lisp
(require 'package)
(setq package-archives
   '(("melpa" . "https://melpa.org/packages/")
     ("gnu" . "https://elpa.gnu.org/packages/")
     ("org" . "http://orgmode.org/elpa/")))
(package-initialize)
#+end_src

*** Set the load path for manually downloaded packages

(Currently I don't use manually downloaded packages)

#+begin_src emacs-lisp
;;(add-to-list 'load-path "~/Dropbox/Organisation/setup/emacs/downloaded-packages")
#+end_src

** ~agda~ mode

We need Emacs to locate Agda mode. This command is put in ~.emacs~

#+begin_src emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
                (shell-command-to-string "agda-mode locate")))
#+end_src

#+begin_src emacs-lisp
(require 'agda-input)
(require 'agda2-highlight)
#+end_src

*** Command line arguments

Dr. Wolfram Kahl has recommended customising the following settings.
(note that my machine is a virtual machine running on a Chromebook
with a little less than ~5G~ available to it).

#+begin_src emacs-lisp
(setq agda2-program-args (quote ("+RTS" "-M3G" "-H3G" "-A128M" "-RTS")))
#+end_src

These arguments specify
| ~+RTS~, ~-RTS~ | Flags between these are arguments to the ~ghc~ runtime |
| ~-M[size]~   | Maximum heap size                                    |
| ~-H[size]~   | Suggested heap size                                  |
| ~-A[size]~   | Allocation area size used by the garbage collector   |

Full documentation for the ~ghc~ runtime argumentscan be found [[https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/runtime-control.html][here]].

Additional arguments that may be useful include
| ~-S[file]~ | Produces information about “each and every garbage collection” |
|          | - Outputs to ~stderr~ by default                               |

*** Alternative problem highlighting

I find the background coloring used by Agda for incomplete pattern matching,
redundant clauses and clauses which do not hold definitionally hard to read
in general, and usually unreadable with different themes.

So I use set other indicators instead.

#+begin_src emacs-lisp
(defun my-agda-highlighting ()
  "Set face attributes to replace Agda highlighting,
  which I find hard to read in many situations."
  (set-face-attribute
    'agda2-highlight-coverage-problem-face
    nil ;; all frames
    :background nil
    :underline "dark red"
  )
  (set-face-attribute
    'agda2-highlight-deadcode-face
    nil ;; all frames
    :background nil
    :strike-through t
  )
  (set-face-attribute
    'agda2-highlight-catchall-clause-face
    nil ;; all frames
    :background nil
    :slant 'italic
  )
)

(add-hook 'agda2-mode-hook 'my-agda-highlighting)
#+end_src

*** Add unicode characters to Agda's translations

**** Punctuation and parentheses

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '(";;" "﹔"))
(add-to-list 'agda-input-user-translations '(";;" "⨾"))
(add-to-list 'agda-input-user-translations '("|" "❙"))
(add-to-list 'agda-input-user-translations '("st" "•"))
(add-to-list 'agda-input-user-translations '("{" "｛"))
(add-to-list 'agda-input-user-translations '("}" "｝"))
(add-to-list 'agda-input-user-translations '("{" "⁅"))
(add-to-list 'agda-input-user-translations '("}" "⁆"))
#+end_src

**** Correct mistakes on subscripts/superscripts

I often accidentally hold the shift key for too long when entering
subscripts and superscripts; these translations account for that.

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("^!" "¹"))
(add-to-list 'agda-input-user-translations '("^@" "²"))
(add-to-list 'agda-input-user-translations '("^#" "³"))
(add-to-list 'agda-input-user-translations '("^$" "⁴"))
(add-to-list 'agda-input-user-translations '("^%" "⁵"))
(add-to-list 'agda-input-user-translations '("^^" "⁶"))
(add-to-list 'agda-input-user-translations '("^&" "⁷"))
(add-to-list 'agda-input-user-translations '("^*" "⁸"))
(add-to-list 'agda-input-user-translations '("^(" "⁹"))
(add-to-list 'agda-input-user-translations '("^)" "⁰"))
(add-to-list 'agda-input-user-translations '("_!" "₁"))
(add-to-list 'agda-input-user-translations '("_@" "₂"))
(add-to-list 'agda-input-user-translations '("_#" "₃"))
(add-to-list 'agda-input-user-translations '("_$" "₄"))
(add-to-list 'agda-input-user-translations '("_%" "₅"))
(add-to-list 'agda-input-user-translations '("_^" "₆"))
(add-to-list 'agda-input-user-translations '("_&" "₇"))
(add-to-list 'agda-input-user-translations '("_*" "₈"))
(add-to-list 'agda-input-user-translations '("_(" "₉"))
(add-to-list 'agda-input-user-translations '("_)" "₀"))
#+end_src

**** Activate the new additions

#+begin_src emacs-lisp
(agda-input-setup)
#+end_src

*** Activate Agda input mode in ~text~ and ~prog~ modes

#+begin_src emacs-lisp
(add-hook 'text-mode-hook
       (lambda () (set-input-method "Agda")))
(add-hook 'prog-mode-hook
       (lambda () (set-input-method "Agda")))
#+end_src

** ~org~ mode

#+begin_src emacs-lisp
(require 'org)
(require 'ox-extra)
#+end_src

*** Capture

I'm beginning to use ~org-capture~ to enable me to log
ideas/TODO items from anywhere in Emacs in my log file.

#+begin_src emacs-lisp
(setq org-default-notes-file "~/Dropbox/Organisation/log/log.org")
#+end_src

Currently I just use the default capture template,
and manually organise ideas later.
Once I use this system for a while,
I should ideally set up other templates to automate some of this.

*** Agenda

My log file is my agenda.

#+begin_src emacs-lisp
(setq org-agenda-files '("~/Dropbox/Organisation/log/log.org"))
#+end_src

*** Speed keys

Speed keys are single keystrokes which execute commands in an
~org~ file when the cursor is at the start of a headline.

#+begin_src emacs-lisp
(setq org-use-speed-commands t)
#+end_src

To see the commands available, execute
#+begin_example emacs-lisp
(org-speed-command-help)
#+end_example

*** Exporting

**** Allow for ignoring headlines and/or subtrees

Use the ~:ignore:~ tag on headlines to omit the headline when
exporting, but keep its contents.

#+begin_src emacs-lisp
(ox-extras-activate '(ignore-headlines))
#+end_src

Alternatively, use the ~:noexport:~ tag to omit the headline
/and/ its contents.

#+begin_src emacs-lisp
;;;; noexport is in the list by default
;; (add-to-list 'org-export-exclude-tags "noexport")
#+end_src

**** Source code block indentation and colouring

I want to preserve my indentation for source code during export.
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

The ~htmlize~ package preserves source code colouring on export to html.
(And presumably does a lot more I am not fully aware of).
#+begin_src emacs-lisp
(require 'htmlize)
#+end_src

**** Export in the background

Using ~latex-mk~, the export process takes a bit of time.
Tying up emacs during that time is annoying, so set the
export to happen in the background.
This setting can be modified locally in the export dialog frame
if desired.

#+begin_src emacs-lisp
(setq org-export-in-background t)
#+end_src

This works by spawning a new Emacs session.
That session uses this init file, so we must be careful
that this file works for daemon (headless) Emacs processes.
See [[Buffers to open upon setup]] for how to deal with
problematic portions.

Another possible solution would be to modify
~org-export-async-init-file~, but that would require
creation of a new init file. To use this approach, I would
have to repeat large portions of this file.
If this approach is ever desirable,
this [[https://superuser.com/a/898717/1032497][answer on StackExchange]] describes how to create such a file
using Lisp code.

**** LaTeX specific

***** Default LaTeX compiler

I use a lot of unicode, and I find ~xelatex~ and ~lualatex~
handle that more easily than ~pdflatex~.

From my experience so far, they seem pretty interchangable
for my purposes, so the decision of which to use is arbitrary.

Based on [[https://tex.stackexchange.com/questions/36/differences-between-luatex-context-and-xetex][this discussion on Stack Exchange]], LuaTeX seems the more
“up and coming” engine, so I'm using it at least until something breaks.

#+begin_src emacs-lisp
(setq org-latex-compiler "lualatex")
#+end_src

***** LaTeX compilation process

I use ~latexmk~ to automatically run as many passes as needed
to resolve references, etc.

#+begin_src emacs-lisp
(setq org-latex-pdf-process
      '("latexmk -%latex -f %f"))
#+end_src

The flags/format specifiers are
| ~%latex~        | stands in for the latex compiler (defaults to the setting above) |
| ~-f~            | force continued processing past errors                           |
| ~%f~            | stands in for the (relative) filename                            |

Other flags/format specifiers I may wish to add later include
| ~-shell-escape~ | necessary to use ~minted~ |

***** Custom document classes

I want a ~report~ class that begins with ~chapter~'s, rather than
~part~'s.

#+begin_src emacs-lisp
(add-to-list
  'org-latex-classes
    '("report-noparts"
      "\\documentclass{report}"
      ("\\chapter{%s}" . "\\chapter*{%s}")
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

Sometimes, for creating slides, ~beamer~ is useful.
(Though I try to avoid it now; it feels low level to me).

#+begin_src emacs-lisp
(add-to-list
  'org-latex-classes
    '("beamer"
      "\\documentclass[presentation]{beamer}"
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
#+end_src

***** Source code colouring in LaTeX exports

We can use ~minted~ for source code colouring on export to LaTeX.

Currently this breaks things with my literate Agda process,
a problem I should resolve. For the moment, if I want to use
~minted~, I can do so on a file-by-file basis.

⟪ ~pygments~ (also called ~python-pygments~) must be installed on the
  system for this to work. ⟫

#+begin_src emacs-lisp
;;(setq org-latex-listings 'minted
;;      org-latex-packages-alist '(("" "minted")))
#+end_src
**** ~org-reveal~

I make use of ~org-reveal~ to create ~reveal.js~ slide decks.
This is way easier than dealing with ~beamer~ in LaTeX,
and results in much more attractive and better organised slides.

#+begin_src emacs-lisp
(require 'ox-reveal)

(setq org-reveal-root "file:///home/markparmstrong/Dropbox/Organisation/downloaded/reveal.js-3.8.0/")
#+end_src

***** Slide appearance

****** Theme

~reveal.js~ comes with many themes; ~black~ is the current default
at time of writing this. I set it just to be sure it stays consistent..

#+begin_src emacs-lisp
(setq org-reveal-theme "black")
#+end_src

At the time of writing, the included themes are
- ~black~: Black background, white text, blue links
- ~white~: White background, black text, blue links
- ~league~: Gray background, white text, blue links
- ~beige~: Beige background, dark text, brown links
- ~sky~: Blue background, thin dark text, blue links
- ~night~: Black background, thick white text, orange links
- ~serif~: Cappuccino background, gray text, brown links
- ~simple~: White background, black text, blue links
- ~solarized~: Cream-colored background, dark green text, blue links
(list from the [[https://github.com/hakimel/reveal.js/#theming][~reveal.js~ github]]).

****** Title page

The default title slide includes title and date, with the formatting
#+begin_src html
<h1 class="title">%t</h1><p class="date">Created: %d/p>
#+end_src
where ~%t~ stands for the document title and ~%d~ stands for the date.
I override this setting
#+begin_src emacs-lisp
(setq org-reveal-title-slide "<h2 class=\"title\">%t</h2><h3>%a</h3><h4>%d</h4>")
#+end_src

****** Default slide height, width, margin and scaling

#+begin_src emacs-lisp
(setq org-reveal-height 800)
(setq org-reveal-width 1200)
(setq org-reveal-margin "0.1")
(setq org-reveal-min-scale "0.05")
(setq org-reveal-max-scale "5")
#+end_src

*** Evaluating code

By default, Emacs will query whether we /actually/ want to
execute code when we evaluate a code block. Also, it seems to
just /not/ execute code marked for execution during export in an
~org~ file. So, I remove the safety.
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

Loading the following languages with ~require~ allows code blocks
in them to be evaluated.

By default only emacs lisp can be evaluated.

Documentation [[https://orgmode.org/manual/Languages.html][here]].

#+begin_src emacs-lisp
(require 'ob-C)
(require 'ob-haskell)
(require 'ob-latex)
(require 'ob-shell)
(require 'ob-ruby)
#+end_src

For shell code, we need to initialise via this function.
See [[https://emacs.stackexchange.com/questions/37692/how-to-fix-symbols-function-definition-is-void-org-babel-get-header][here]].
#+begin_src emacs-lisp
(org-babel-shell-initialize)
#+end_src

*** Cosmetics

**** Indent text based on heading by default

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
#+end_src

**** Hide emphasis markers by default

#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

**** Highlight math mode blocks

 #+begin_src emacs-lisp
 (setq org-highlight-latex-and-related '(latex))
 #+end_src

** ~pdf-tools~

Need to “install” it each time emacs starts
#+begin_src emacs-lisp
(pdf-tools-install)
#+end_src

*** COMMENT Default to midnight mode

#+begin_src emacs-lisp
(add-hook 'pdf-tools-enabled-hook 'pdf-view-midnight-minor-mode)
#+end_src

** ~yankpad~ and ~yasnippets~

I use ~yasnippets~ for text expansion, and ~yankpad~ to organise my
snippets.

#+begin_src emacs-lisp
(require 'yasnippet)
(yas-global-mode t)

(require 'yankpad)
(setq yankpad-file "~/Dropbox/Organisation/setup/emacs/yankpad.org")
#+end_src

~yas-wrap-around-region~ controls what is inserted for a snippet's
~$0~ field. A non-nil, non-character setting has it insert the
current region's contents (i.e. if we highlight a region and
invoke a snippet, the region will be wrapped).

#+begin_src emacs-lisp
(setq yas-wrap-around-region t)
#+end_src

~yas-indent-line~ controls how inserted snippets are inserted.
~fixed~ indicates the snippet should be indented to the column at point.
~auto~ instead causes each line to be indented using ~indent-according-to-mode~.
I set it to fixed because this is usually what I want; I know best, not the mode.

#+begin_src emacs-lisp
(setq yas-indent-line 'fixed)
#+end_src

*** Don't add a final newline when editing snippet files

~yasnippets~ will insert the final newline when expanding a snippet,
so snippet files generally shouldn't include a final newline.

#+begin_src emacs-lisp
(add-hook 'snippet-mode-hook (setq require-final-newline nil))
#+end_src

*** COMMENT Make ~org~ mode “play nice” with ~yasnippets~

This is deprecated, since I use ~yankpad~ as a front end to ~yasnippets~
now.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (lambda ()
            (setq-local yas/trigger-key [tab])
            (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))
#+end_src

** ~dired~

I use ~dired~ for browsing directories; it's simple, and with
the right configuration, very easy to use.

*** Display preferences

~dired~ makes use of switches for ~ls~.

I like the following switches:
| ~--group-directories-first~ | group directories before files                             |
| ~-a~                        | do not ignore entries starting with .                      |
| ~-B~                        | do not list implied entries ending with ~                  |
| ~-g~                        | long listing format, but do not list owner                 |
| ~-G~                        | in a long listing, don't print group names                 |
| ~-h~                        | print human readable size                                  |
| ~-L~                        | show information for /references/ rather than symbolic links |

#+begin_src emacs-lisp
(setq dired-listing-switches "--group-directories-first -aBgGhL")
#+end_src

*** Use only one buffer for ~dired~

I use ~dired-single~ to avoid ~dired~ opening a new buffer
for every directory visited.

#+begin_src emacs-lisp
(require 'dired-single)
#+end_src

I use a “magic” buffer with the name ~*Dired*~, to avoid the single
~dired~ buffer being named after whatever directory I first visit.

#+begin_src emacs-lisp
(setq dired-single-use-magic-buffer t)
(setq dired-single-magic-buffer-name "*Dired*")
#+end_src

The below code, which rebinds keys to use ~dired-single~ rather than ~dired~,
is taken directly from the ~dired-single~ [[https://github.com/crocket/dired-single][GitHub readme]].

#+begin_src emacs-lisp
(defun my-dired-init ()
  "Bunch of stuff to run for dired, either immediately or when it's
   loaded."
  ;; <add other stuff here>
  (define-key dired-mode-map [return] 'dired-single-buffer)
  (define-key dired-mode-map [mouse-1] 'dired-single-buffer-mouse)
  (define-key dired-mode-map "." 'dired-single-up-directory)
)

;; if dired's already loaded, then the keymap will be bound
(if (boundp 'dired-mode-map)
        ;; we're good to go; just add our bindings
        (my-dired-init)
  ;; it's not loaded yet, so add our bindings to the load-hook
  (add-hook 'dired-load-hook 'my-dired-init))
#+end_src

* Key bindings

I make use of ~hydra~ for keybindings (or groups of keybindings)
which will be executed several times in a row.

I also make use of ~general~ to organise other keybindings.

#+begin_src emacs-lisp
(require 'general)
#+end_src

** ~general~ definers

You can use ~general-define-key~ directly to define shortcuts,
ideally using the keyword argument ~:prefix~ to avoid repeating
prefixes, but if you are (even only possibly)
using a prefix several times,
it's better to create a custom function to use instead of
~general-define-key~.

Setting ~:keymaps~ to ~'override~ ensures that no package will
override my shortcuts.

For the moment, I'm experimenting with using ~s~-key (“super”-key)
combinations as prefixes. I have my caps lock bound to super
(on my Chromebook's internal keyboard it's bound to that by
default), and I think if I restrict the combination keys to
those on the left side of the keyboard, I can avoid “Emacs pinky”.

So far I have three categories of shortcuts:
- My main shortcuts, those that don't fall into another category.
- Shortcuts to navigate around the current buffer.
- Shortcuts to open a ~dired~ buffer for a certain folder.

#+begin_src emacs-lisp
(general-create-definer general-main-define-key
  :prefix "s-a"
  :keymaps 'override)

(general-create-definer general-buf-nav-define-key
  :prefix "s-w"
  :keymaps 'override)

(general-create-definer general-dired-define-key
  :prefix "s-d"
  :keymaps 'override)
#+end_src

** ~yankpad~

I use a non-prefixed shortcut for snippet expansion, since
I do it all the time.
(at least until yankpad has smart tab expansion).
#+begin_src emacs-lisp
(general-define-key
  "s-f" 'yankpad-expand)
#+end_src

Alternatively, ~y m~ invokes ~yankpad-map~, which brings up a
keymap of the last tags of snippets.
#+begin_src emacs-lisp
(general-main-define-key
  "y m" 'yankpad-map)
#+end_src

Changes to the yankpad file require ~yankpad-reload~ to be run
to re-cache the snippets. For the moment, it seems like there is
separate caching for each buffer, meaning this command has to be
run in every buffer where I want changes to be picked up.
So, I have a shortcut key.
#+begin_src emacs-lisp
(general-main-define-key
  "y r" 'yankpad-reload)
#+end_src

** ~dired~

I use shortcuts to jump to frequently used directories in ~dired~
(from any buffer, not just while in ~dired~).

As seen in ~Cosmetics~, I use ~dired-single~ in order to only have one
~dired~ buffer at a time. In case this changes, I define another
local variable to store the command to invoke ~dired~ with.
#+begin_src emacs-lisp
(defun my-dired-invocation (directory)
  "My custom dired invocation.
   It will use my special “magic buffer” for browsing."
  (dired-single-magic-buffer directory))
#+end_src

#+begin_src emacs-lisp
(general-dired-define-key
  "h" '((lambda () (interactive)
          (my-dired-invocation "~"))
        :which-key "Home")
  "o" '((lambda () (interactive)
          (my-dired-invocation "~/Dropbox/Organisation/"))
        :which-key "Organisation")
  "p" '((lambda () (interactive)
          (my-dired-invocation "~/Dropbox/Projects/"))
        :which-key "Projects")
  "m" '((lambda () (interactive)
          (my-dired-invocation "~/Dropbox/McMaster/"))
        :which-key "McMaster")
  "t" '((lambda () (interactive)
          (my-dired-invocation "~/Dropbox/McMaster/Agda/thesis/"))
        :which-key "Thesis")
  "e" '((lambda () (interactive)
          (my-dired-invocation "~/Dropbox/McMaster/3ea3/"))
        :which-key "3ea3")
)
#+end_src

** Navigation

#+begin_src emacs-lisp
(general-buf-nav-define-key
  "r" (lambda () (interactive) (revert-buffer () t ()))
  "u" (lambda () (interactive) (undo-tree-visualize))
  "b" (lambda () (interactive) (beginning-of-buffer))
  "e" (lambda () (interactive) (end-of-buffer))
  "t t" (lambda () (interactive) (toggle-my-themes))
  "t c" (lambda () (interactive) (disable-all-custom-themes))
  "<right>" (lambda () (interactive) (windmove-right))
  "<left>" (lambda () (interactive) (windmove-left))
  "<up>" (lambda () (interactive) (windmove-up))
  "<down>" (lambda () (interactive) (windmove-down))
)
#+end_src

** ~magit~

#+begin_src emacs-lisp
(general-main-define-key
  "g" 'magit-status
)
#+end_src

** Other

#+begin_src emacs-lisp
(general-main-define-key
  "j" 'dad-joke
)
#+end_src

* Navigation

** Jump between windows using ~windmove~

The package ~windmove~ lets us jump between windows in a frame.

#+begin_src emacs-lisp
(require 'windmove)
#+end_src

For the uninitiated, a /window/ in Emacs is not the same as
the OS window. Each OS window is a /frame/, and each pane within
a frame is called a /window/. (Emacs predates modern terminology).

~windmove~ lets us move between windows with the arrow keys
while holding a key; by default, the key is ~shift~.
That conflicts with ~org~ though, so we could use
~windmove-default-keybindings~ to change it.

Unfortunately, on my system, all the other possibilities seem
to be taken with system shortcuts (which I cannot modify in ChromeOS),
or otherwise taken in Emacs.

So instead I've define shortcuts using ~general~ above.

** Change scrolling (shortcut) behaviour

I find the scrolling shortcuts ~scroll-up-command~ (~C-v~)
and ~scroll-down-command~ (~M-v~) “too aggressive”.
They scroll the screen by nearly the whole window height,
by default leaving visible only 2 lines which were visible.

I find adjusting this upwards makes it easier to follow along
with a document as scrolling.
#+begin_src emacs-lisp
(setq next-screen-context-lines 16)
#+end_src

Keep in mind ~recenter~ (~C-l~) when scrolling this way to recenter
the screen on the current line.

* Cosmetics

** Displaying/removing information and interface elements

There are several tweaks I like to display important information
and hide unimportant information or interfact elements.

*** Remove unnecessary interface elements

Emacs usually shows a splash screen on startup,
which doesn't interest me.

#+begin_src emacs-lisp
(setq inhibit-splash-screen t)
#+end_src

I don't use the tool bar (icons below the menu bar).
(This setting must be ~-1~, not ~()~).

#+begin_src emacs-lisp
(tool-bar-mode -1)
#+end_src

I also don't use the menu bar.
(Again, this must be ~-1~, not ~()~).

#+begin_src emacs-lisp
(menu-bar-mode -1)
#+end_src

I also disable the scroll bars.

#+begin_src emacs-lisp
(scroll-bar-mode -1)
#+end_src

*** Prompts for important things

I rarely /actually/ want to close Emacs, so it should always
prompt if I accidentally ask to close.

#+begin_src emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+end_src

*** Information in the mode line

The doom themes package comes with a function to make
the mode line flash on error.
#+begin_src emacs-lisp
(doom-themes-visual-bell-config)
#+end_src

I'd previously just used ~visible-bell~, but it's a bit nosier
than necessary.
#+begin_src emacs-lisp
;;(setq visible-bell t)
#+end_src

I also like the mode line to show the data and time.
#+begin_src emacs-lisp
(setq display-time-day-and-date t)
(setq display-time-24h-format t)
(display-time)
#+end_src

It's also useful to see the line number and column number.
#+begin_src emacs-lisp
(line-number-mode t)
(column-number-mode t)
#+end_src

**** Diminish minor mode names

I use a lot of minor modes, so the mode list takes up a lot
of space on the mode line.

~diminish-mode~ alleviates this by allowing us to hide modes
or give them shorter names.

#+begin_src emacs-lisp
(require 'diminish)
#+end_src

I don't need to see that these modes are active.
#+begin_src emacs-lisp
(eval-after-load "yas-minor-mode" '(diminish 'yas-minor-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
(eval-after-load "which-key" '(diminish 'which-key-mode))
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+end_src

If later I want to rename modes, just add a string argument
to the above form with a (presumably shorter) name.

*** Show line numbers on left (for ~text~ and ~prog~ mode)

I like to have line numbers displayed, but ~linum-mode~
conflicts with ~pdf-tools~. So instead of ~global-linum-mode~,
I enable it for ~text~ and ~prog~ modes.

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'linum-mode)
(add-hook 'prog-mode-hook 'linum-mode)
#+end_src

*** Highlight matching parenthesis when cursor is near

 #+begin_src emacs-lisp
 (load-library "paren")
 (show-paren-mode 1)
 (transient-mark-mode t)
 (require 'paren)
 #+end_src

*** Show trailing whitespace

It's good style not to have trailing whitespace.
~show-trailing-whitespace~ will colour any trailing whitespace.

#+begin_src emacs-lisp
(setq show-trailing-whitespace t)
#+end_src

This can be a little annoying, so I should add a way to turn
it off.

**** TODO toggle show-trailing-whitespace

*** Show ruler at 80 characters for (for ~text~ and ~prog~ mode)

It's also good style to keep lines under 80 characters wide.
~fill-column-indicator~ will display a line (by default at 70 characters)

One thing worth noting is that with ~org-indent-mode~,
the line will be off by the length of the indentation
(i.e. it will be at line 68 if indented 2 characters,
66 if indented 4, etc.).

The code to make it a global mode is from the [[https://www.emacswiki.org/emacs/FillColumnIndicator][Emacs wiki]].

#+begin_src emacs-lisp
;;(require 'fill-column-indicator)
;;(define-globalized-minor-mode global-fci-mode fci-mode (lambda () (fci-mode t)))
;;(global-fci-mode t)
#+end_src

If I later need it enabled only for certain modes,
this code could be of use.
#+begin_src emacs-lisp
;; (require 'fill-column-indicator)
;; (add-hook 'text-mode-hook 'fci-mode)
;; (add-hook 'prog-mode-hook 'fci-mode)
#+end_src

*** Wrap lines

Since I make an effort to keep my lines under 80 characters,
I usually won't have lines too long for the window.

If there are such lines, though, horizontally scrolling is
annoying (or at least I find it so in Emacs).

~visual-line-mode~ will “wrap” lines which are too long.

#+begin_src emacs-lisp
(global-visual-line-mode t)
#+end_src

This can be annoying if working with a file with lots of long
lines, so I should add a way to turn it off.

**** TODO toggle visual-line-mode

** Themes

I use the ~doom-nord~ themes,
and toggle between the non-~light~ and ~light~ variants.

#+begin_src emacs-lisp
(load-theme 'doom-nord t)

(setq my-dark-theme 'doom-nord)
(setq my-light-theme 'doom-nord-light)

(defun disable-all-custom-themes ()
  "Disable all custom themes.
   Returns the previous highest precendence theme
   (nil if no themes were previously enabled).

   Implementation:
     Gets the highest precedence applied theme as the first element
     of custom-enabled-themes.

     Then iteratively disables all the themes in custom-enabled-themes.
  "
  (let ((most-recent-theme (car custom-enabled-themes)))
    (while (car custom-enabled-themes)
      (disable-theme (car custom-enabled-themes)))
    most-recent-theme
  )
)

(defun toggle-my-themes ()
  "Disable all custom, then try to toggle the themes
   my-dark-theme and my-light-theme, in that if one was
   the last applied theme, the other will be applied.

   If neither was the last applied theme, my-dark-theme
   will be applied as a default.
  "

  (let ((most-recent-theme (disable-all-custom-themes)))
    (if (eq most-recent-theme my-dark-theme)
        (load-theme my-light-theme)
        (load-theme my-dark-theme)
    )
  )
)

(eq (car custom-enabled-themes) my-dark-theme)
(disable-all-custom-themes)
(toggle-my-themes)
#+end_src

Make it “play nice” with ~org~

#+begin_src emacs-lisp
(doom-themes-org-config)
#+end_src

** Automatically revert unchanged files which change on the disk

#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src

** TODO Use ~wordsmith~ for English syntax highlighting

#+begin_src emacs-lisp
(require 'wordsmith-mode)
#+end_src

** Show possible completions as I type shortcuts

#+begin_src emacs-lisp
(require 'which-key)
(which-key-mode)
#+end_src

** Provide a visualisation of my undo tree

In Emacs, changes to a buffer are stored using a tree,
rather than a stack.

In most editors if we revert to an earlier state using “undo”
and then make some changes, we can no longer reach the
state /before/ the “undo”, because it was popped of the stack
and is now lost (the “redo” stack was lost when we made changes).

This doesn't happen with an “undo tree”!

I like to think of the undo tree as “extemely local” version control.

The package ~undo-tree~ provides a visualisation of the undo tree.

#+begin_src emacs-lisp
(require 'undo-tree)
(global-undo-tree-mode)
#+end_src

I like each node in the undo tree to have a timestamp;
it helps identify the node I want to return to.

#+begin_src emacs-lisp
(setq undo-tree-visualizer-timestamps t)
#+end_src

We can have a “diff” window display the changes made at each
node in the undo tree.

Unfortunately this seems to introduce a fair amount of lag
on my system.

#+begin_src emacs-lisp
;;(setq undo-tree-visualizer-diff ())
#+end_src

** Buffers to open upon startup

Note that this portion of the file should be /after/ any settings
that would affect these buffers.

This portion of the file should only be run if the Emacs process
is not headless. In the case that Emacs is running as a daemon,
as it does when initiating an asynchronous process such as
an Org async export process.

#+begin_src emacs-lisp
(if (display-graphic-p) (progn
#+end_src

Otherwise those settings will not apply in these buffers.

I like a bunch of files open upon startup.
#+begin_src emacs-lisp
  (find-file "~/Dropbox/Organisation/setup/emacs/tips-and-tricks.org")
  (find-file "~/Dropbox/Organisation/setup/emacs/yankpad.org")
  (find-file "~/Dropbox/McMaster/Agda/scratch.agda")
  (find-file "~/Dropbox/Organisation/log/phone-log.org")
#+end_src

These last files are the ones I want “in focus” upon startup.
I move to the end of the log to ensure any junk input gets placed there.
#+begin_src emacs-lisp
  (find-file "~/Dropbox/Organisation/setup/emacs/emacs-init.org")
  (split-window-right)
  (windmove-right)
  (find-file "~/Dropbox/Organisation/log/log.org")
  (windmove-left)
  (split-window-below)
  (windmove-down)
  (find-file "~/Dropbox/Organisation/org-scratch.org")
  (end-of-buffer)
#+end_src

We must end the ~if~ above; in the case that we are running in headless mode,
just do nothing here.
#+begin_src emacs-lisp
) nil)
#+end_src

* Other

** Run my custom “dropbox start” command to ensure dropbox is running on the system

#+begin_src emacs-lisp
(start-process-shell-command "dropbox-start"
                             "*dropbox-start*"
                             "/opt/dropbox-filesystem-fix/dropbox_start.py")
#+end_src

* COMMENT TODO Ideas for additions

- ~C-c n l~ - Move remainder of line to the line below
  (insert newline at point and remove newline at end of the resulting line)

- ~C-c c l~ - Copy some number of lines before point

* Generating the README.md for my Emacs repo

This code generates a ~README.md~ file for my Emacs repo,
including this file and other relevant files.

#+name: readme-generate
#+begin_example emacs-lisp :tangle no :results none :exports none
(with-temp-buffer
  (insert "#+EXPORT_FILE_NAME: README.md
           #+TITLE: My Emacs setup
           #+OPTIONS: toc:nil

           # HTML comments:
           [//]: # \"THIS FILE IS GENERATED BY emacs-init.org.\"

           [//]: # \"IT SHOULD NOT BE MODIFIED DIRECTLY.\"

           This repository contains the files that make up my Emacs setup.

           For the moment, that is my (literate) Emacs initialisation file
           and my ~yankpad~ file.

           #+TOC: headlines 3\n")
  (insert "* ~emacs-init.org~\n")
  (insert "#+INCLUDE: emacs-init.org\n")
  (insert "* ~yankpad.org~\n")
  (insert "#+INCLUDE: yankpad.org\n")
  (org-mode)
  (org-md-export-to-markdown)
)
#+end_example

