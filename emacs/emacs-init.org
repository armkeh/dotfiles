#+Title: Mark Armstrong's literate emacs initialisation
#+Author: Mark Armstrong
#+Description: My (heavily organised) emacs initialisation settings,
#+Description: along with commentary, mostly to help me remember
#+Description: why things are set as they are.
#+Options: num:nil

* Introduction

** Screenshot                                  :ignore:

[[./media/emacs-screenshot-06-26-2021.png]]

** Preamble                                    :ignore:

This document is now in its second major version, having been
started over after it previously grew unwieldly.

This iteration focuses on a more carefully organisation of settings.
Rather than grouping settings by major mode or thematically,
they are grouped by importance.

This grouping allows me to easily reduce my settings to “bare bones”
when needed, without compromising the settings that are most important to me.
And it simplifies the “binary search” approach to debugging,
where we recursively disable roughly half the init file in order
to find the source of some bug.

** Tags

For the sake of searching for settings via their “theme”,
I try to tag headings in this file.

Unfortunately, GitHub's rendering of Org does not include tags,
so these do not show up on GitHub.
But in other formats, you can search by these tags
to find related sections of this file.
On GitHub you may resort to viewing the raw file.

Here is a list of notable tags.
Below, in the raw file, are snippets of code to construct a sparse tree
to bring into view only those headings with that tag
while viewing this file in Emacs.
- ~:org:~; settings for Org mode.
- ~:mail:~; settings for receiving, reading and sending emails.
- ~:programming:~; settings for any programming languages.
- ~:vc:~; settings for version control and related notions,
  such as “diff” and “undo” utilities.
- ~:completion:~; settings for completion frameworks and related notions,
  such as snippets.
- ~:delimiter:~; settings pertaining to delimiters.
- ~:line:~; settings pertaining to the notion of a line.
- ~:space:~; settings dealing with whitespace.
- ~:font:~; settings for font.
- ~:theme:~; settings for theme or other appearance details.
- ~:buffer:~; settings dealing with the notion of buffers.
- ~:window:~; settings dealing with the notion of Emacs windows
  (not OS windows.)
- ~:tab:~; settings dealing with the tab bar.
- ~:basic:~; settings for basic elements of Emacs.
- ~:simplify:~; settings to remove or reduce the visual presence
  of elements of Emacs I either do not use at all or don't use often.
- ~:cleanup:~; portions of the file which are just for cleanup,
  not really for adjusting settings.

*** COMMENT Constructing sparse trees from the tags

Execute these snippets to quickly find headings with a tag.
#+begin_example emacs-lisp
(org-match-sparse-tree nil "org")
(org-match-sparse-tree nil "mail")
(org-match-sparse-tree nil "programming")
(org-match-sparse-tree nil "vc")
(org-match-sparse-tree nil "completion")
(org-match-sparse-tree nil "delimiter")
(org-match-sparse-tree nil "line")
(org-match-sparse-tree nil "space")
(org-match-sparse-tree nil "font")
(org-match-sparse-tree nil "theme")
(org-match-sparse-tree nil "buffer")
(org-match-sparse-tree nil "window")
(org-match-sparse-tree nil "tab")
(org-match-sparse-tree nil "basic")
(org-match-sparse-tree nil "simplify")
(org-match-sparse-tree nil "cleanup")
#+end_example

** The file layout

- [[How to use this file]]
  - Instructions on how this file is to incorporated
    into ones Emacs init.
  - Includes the contents of my “actual” Emacs init file,
    which carries out the incorporation of this file into my init.
- [[Environment setup and package management]]
  - Carries out environment variable setup
    and sets up package management
    that is used to install and set up packages
    in the remainder of the document.
- [[Custom Elisp]]
  - Elisp utilities I have written which have somewhat general purpose,
    so that it is not appropriate for them to be tucked in
    with the settings for a particular package.
  - Some of these utilities are simply waiting
    for a better longterm home.
- [[Simple cosmetics]]
  - Harmless cosmetic changes, that make the worst case of a
    crash during initialisation more comfortable.
    - Nothing that should affect performance.
  - Activation of my themes.
  - Toggle some basic features. Including but not limited to:
    - For instance, disable splash screens, menus and scroll bars,
    - and enable line numbers and highlighting of parentheses.
- [[Vital non-mode-specific settings]]
  - Change Emacs settings that are vitally important,
    but which are not tied to a specific mode.
  - I identify these settings as
    “will I encounter unexpected behaviour or be likely
     to make mistakes when carrying out basic tasks
     if these settings are not established?” 
  - For instance,
    - automatically revert buffers when they've
      changed on the disk,
    - set up proper consideration of delimiters, and
    - ensure indentation behaves correctly.
- [[Vital modes and vital mode-specific settings]]
  - Activate packages I use near constantly, including:
    - Org mode,
    - mu4e, and
    - while I am working on my thesis at least, Agda mode.
  - And change any settings for them that are vital.
- [[Keybindings]]
  - Set up my keybindings.
  - At time of writing, I use [[https://github.com/noctuid/general.el][general]] for all of this setup.
- [[Intermediate cosmetics]]
  - Cosmetics which are not absolutely vital,
    but make me significantly more comfortable and at home.
  - Or cosmetics that may be vital, but were not simple enough
    to set up to go higher, where a failure
    would have more significant repercussions.
  - Including
    - display of some whitespace characters,
    - colouring of delimiters,
    - visuals that assist with distinguish the buffer in use more.
- [[Intermediate modes and intermediate mode-specific settings]]
  - Additional modes and additional settings for modes installed above
    which are not vital, but important.
  - Including:
    - The majority of settings Org mode,
      in particular cosmetic settings
      and exportation settings.
    - Completion and snippets setup.
    - Undo assistants setup.
- [[Final cosmetics]]
  - Any cosmetic settings that didn't fit in above.
  - These should be truly “just for comfort” settings.
- [[Final modes and final mode-specific settings]]
  - Any modes that didn't fit in above.
  - In the future, this section may need to be broken up
    if the number of headings here becomes excessive.
- [[Session setup]]
  - Code to open my starting tabs and files,
    setting up the session for me.
- [[Cleanup]]
  - Any final tasks, including
    - checking that the actual init file has not been tampered with,
    - generating the README for the Emacs directory
      of my dotfiles repo automatically,
    - and as the last action, add a prompt before
      quitting Emacs; if we reach the end of this file,
      everything has gone well and we should be ready to start work,
      so we are unlikely to want to leave Emacs anytime soon.

* How to use this file

I don't like to export this file to the proper Emacs init file,
since that file may be modified by Emacs itself
or sometimes other programs.
(See below where we [[Set a “custom” file]], which should
 avoid most modifications on Emacs' end;
 I've still had external programs feel it's appropriate
 to edit the file without my explicit permission
 (the Agda installation process in particular.))
I like to keep that file a bit bare so I can catch any changes
made to it by entities other than myself.

So instead, I create a symbolic link to this file in ~~/.config/emacs/~,
then add to ~~/.config/emacs/init.el~
(see https://www.gnu.org/software/emacs/manual/html_node/emacs/Find-Init.html
 for a discussion of the acceptable locations for the init file)
these lines:
#+name: dotemacs-expected-elisp
#+begin_src emacs-lisp :tangle /tmp/init.el
;; BEGIN my edits

;; Enable editing of version controlled files through symlinks.
;; Usual setting is to ask, which means asking each time my init is opened
;; since I use a symlink to it.
(setq vc-follow-symlinks t)

;; Delete the old tangled and compiled init file.
;; Shouldn't be necessary, but better safe than sorry.
(delete-file "~/.config/emacs/emacs-init.el")
(delete-file "~/.config/emacs/emacs-init.elc")

;; Load my init file.
(org-babel-load-file "~/.config/emacs/emacs-init.org")

;; END my edits
#+end_src

In [[Cleanup]] below, we check the contents of the proper Emacs init file
against the above contents,
to warn me if changes are made.
Hence why the above source block is tangled to ~/tmp/init.el~.

* Environment setup and package management

Before we really begin, we ensure environment settings are correct
and setup ~use-package~ as a package manager.

** Set a custom file

Emacs will, by default, insert all sorts of “custom” settings
into our actual init file
(~~/.emacs~, ~/.emacs.el~, ~./emacs.d/init.el~, or ~/.config/emacs/init.el~;
 see [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Find-Init.html]])
especially those set via GUIs.

In order to avoid polluting that file, let's set it to use
a particular one. In fact, let's put it under my version control,
so I will be more able to notice changes to it.
#+begin_src emacs-lisp
(setq custom-file "~/dotfiles/emacs/custom.el")
(ignore-errors (load custom-file))
#+end_src

** Basic package management

~package~ gives us the basic tools to add packages from repositories
to Emacs.
#+begin_src emacs-lisp
(require 'package)
#+end_src

We will shortly setup a package manager to ease installation of packages.

** Set package repositories

By default, the only package repository is the ELPA repo.
See the list of packages contained therein [[http://elpa.gnu.org/packages/][here]].

Here we add the MELPA repo and the NonGNU repo,
then refresh to get the latest contents.
#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/"))
(package-initialize)
(package-refresh-contents)
#+end_src

If needed, we can set ~package-archive-priorities~
to set the priority for these repositories.

Older versions of Org and the “Org+Contrib” package were hosted at
http://orgmode.org/elpa/,
but after Org 9.5, they are no longer distributed there.
Now Org is best available though GNU ELPA, and there is a new
“Org-Contrib” package available through NonGNU ELPA
(the + was dropped from the name.)

** Setup use-package, a package management tool

The ~use-package~ package provides an easy-to-use interface
to install and customise packages.

I generally use it just to avoid having to ~package-install~ packages
whenever I migrate systems.
I haven't properly learned how to customise packages using it;
generally I just write my customisations as plain Elisp
after the ~use-package~ invocation to install them.
Where you see me use ~use-package~ to apply customisations,
I have probably copied someone else's initialisation.

Unless it's already installed, update the packages archives,
then install the most recent version of “use-package”.
#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+end_src

I always want to download packages that aren't installed.
#+begin_src emacs-lisp
(setq use-package-always-ensure t)
#+end_src

** Update packages

For the moment, I use the ~auto-package-update~ to automatically update
packages for me.
#+begin_src emacs-lisp
(use-package auto-package-update
  :config
  ;; Delete residual old versions
  (setq auto-package-update-delete-old-versions t)
  ;; Do not bother me when updates have taken place.
  (setq auto-package-update-hide-results t)
  ;; Update installed packages at startup if there is an update pending.
  (auto-package-update-maybe))
#+end_src

** Make sure we have the right path

See https://github.com/purcell/exec-path-from-shell
#+begin_src emacs-lisp
(use-package exec-path-from-shell)
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+end_src

** Add directories to the Emacs load path

Elisp files installed as part of a package
from an external package manager are, by convention,
installed under a relevant ~share~ directory.

Here we check if those install locations exist on the system,
and if so, add their subdirectories to the Emacs load path.

Rather than simply adding to ~load-path~, we recursively add
all subdirectories of the directory in question
using the ~normal-top-level-add-subdirs-to-loadpath~.
This function works out of the directory
pointed to by the ~default-directory~ variable;
so we rebind that locally before the call
(and make use of dynamic scoping).
See https://www.emacswiki.org/emacs/LoadPath.

The Debian package manager ~apt~ installs
to an ~emacs/site-lisp~ folder.
#+begin_src emacs-lisp
(let ((default-directory "/usr/local/share/emacs/site-lisp/"))
  (when (file-directory-p default-directory)
    (normal-top-level-add-subdirs-to-load-path)))
#+end_src

Guix and Nix both install Elisp under the ~share/emacs~ directories
within their profile folder.
I only use a single profile, so no need to hunt out the correct one.
#+begin_src emacs-lisp
(let ((default-directory "~/.guix-profile/share/emacs/"))
  (when (file-directory-p default-directory)
    (normal-top-level-add-subdirs-to-load-path)))

(let ((dir "~/.nix-profile/share/emacs/"))
  (when (file-directory-p dir)
    (normal-top-level-add-subdirs-to-load-path)))
#+end_src

** Set a custom directory for non-package manager managed Elisp files

This directory is for Elisp files I develop myself
or that I download without use of a package manager.

As above, add recursively add all subdirectories of this directory
to the load path, so that git repositories can be added here
as subtrees in this directory, and the ~.el~ files will be picked up.
But do also pick up Elisp files found at the top of the directory.
#+begin_src emacs-lisp
(let ((default-directory "~/dotfiles/emacs/elisp"))
  (add-to-list 'load-path default-directory) ;; Load files at the top of the directory.
  (normal-top-level-add-subdirs-to-load-path))
#+end_src

** Elisp utilities

These utility packages simplify many families of tasks.

~s~ is for ~s~-tring management.
#+begin_src emacs-lisp
(use-package s)
#+end_src

~f~ is for ~f~-ile management.
#+begin_src emacs-lisp
(use-package f)
#+end_src

* Custom Elisp

Some of this code may be moved to separate files later,
but it's small and collected here for now.

** Toggle themes

These functions allow me to clear and toggle my themes.
#+begin_src emacs-lisp
(defun disable-all-custom-themes ()
  "Disable all custom themes.
   Returns the previous highest precendence theme
   (nil if no themes were previously enabled).

   Implementation:
     Gets the highest precedence applied theme as the first element
     of custom-enabled-themes.

     Then iteratively disables all the themes in custom-enabled-themes.
  "
  (let ((most-recent-theme (car custom-enabled-themes)))
    (while (car custom-enabled-themes)
      (disable-theme (car custom-enabled-themes)))
    most-recent-theme))

(defun toggle-my-themes ()
  "Disable all custom, then try to toggle the themes
   my-dark-theme and my-light-theme, in that if one was
   the last applied theme, the other will be applied.

   If neither was the last applied theme, my-dark-theme
   will be applied as a default.
  "

  (let ((most-recent-theme (disable-all-custom-themes)))
    (if (eq most-recent-theme my/dark-theme)
        (load-theme my/light-theme t)
        (load-theme my/dark-theme t))))
#+end_src

** Theme change hook

[[https://www.reddit.com/r/emacs/comments/4v7tcj/][Apparently]],
there is no hook in Emacs for when a theme change occurs.
This code snippet, taken from the linked reddit post, defines one I can use.
#+begin_src emacs-lisp
(defvar after-load-theme-hook nil
  "Hook run after a color theme is loaded using `load-theme'.")
(defadvice load-theme (after run-after-load-theme-hook activate)
  "Run `after-load-theme-hook'."
  (run-hooks 'after-load-theme-hook))
#+end_src

** Cascading window setup

I set up my default desktop using a “cascading pattern”,
moving from larger windows in the upper right to
smaller windows in the lower left.

This works best with 2 or 3 windows, but it can be used for more.

The process is:
- If there are two or more files left to open:
  - Create a new window to the left.
  - Open the next file.
  - Move the focus to the left.
  - If there are two or more files left to open:
    - Create a new window below.
    - Open the next file.
    - Move focus down.
- Else if there is one file left to open,
  open it.
- Else, quit.
#+begin_src emacs-lisp
(defun cascading-find-files (files)
  "Opens a set of files in a cascading series of windows,
created by splitting the current window.
The windows begin in the upper right, with the first file,
and move left and then down, each window being half the size
of the previous (as long as this is possible)."
  (while files ;; there's at least one file to open
    (find-file (car files))
    (setq files (cdr files))
    (when files ;; there are two or more files
      (split-window nil nil 'left)
      (other-window 1)
      (find-file (car files)) ;; open second file on the left
      (setq files  (cdr files))
      (when files ;; there are still more files, so split horizontally
        (split-window nil nil 'below)
        (other-window 1)))))
#+end_src

:TODO: Create a alternate method for vertical screens, preferably also allowing on-the-fly switching between the two setups.

** Killing a buffer when its associated process finishes

When starting an asynchronous process using ~async-shell-command~,
a buffer is created and brought into focus in another window
to show the output of the command.

We can use ~start-process~ or other functions to start
asynchronous processes without bringing into display,
if that's desired. Instead of that though,
I often want to see the output,
but don't want the buffer to remain once the process
has finished.

This function can be assigned to a sentinel for a process
to kill its associated buffer when the process finishes.
#+begin_src emacs-lisp
(defun kill-buffer-on-process-finish (process signal)
  (when (memq (process-status process) '(exit signal))
    (kill-buffer (process-buffer process))
    (shell-command-sentinel process signal)))
#+end_src

* Simple cosmetics

** Disable the splashscreen and open this file :basic:simplify:

This way, if something goes wrong below, I am positioned to fix it
right away.
#+begin_src emacs-lisp
(setq inhibit-splash-screen t)
(setq my/emacs-init-file "~/.config/emacs/emacs-init.org")
(find-file my/emacs-init-file)
#+end_src
This file will be closed and re-opened below, to ensure
all cosmetic changes show correctly.

** Disable unnecessary interface elements      :basic:simplify:

I don't use the menubar, toolbar (icons usually below the menu),
or scroll bars.
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

** Fonts                                       :font:

:TODO: Check if these fonts are installed on the system first, so we don't end up with unknown font settings.

I currently use the [[https://github.com/be5invis/Iosevka][Iosevka]] family of fonts,
because of their efficient saving of horizontal space.
Set it as the default font and the fixed-pitch font.
Again, for space saving, I like a relatively small font;
100 seems to be a sweet spot with this font;
smaller makes some unicode characters hard to see.
#+begin_src emacs-lisp
(set-face-attribute 'default nil :family "Iosevka" :height 100)
(set-face-attribute 'fixed-pitch nil :family "Iosevka")
#+end_src
Notice that for the default font, we specify an explicit height;
the heights for other fonts are relative to this.
(So if their heights were to be specified, it should be as a multiplier,
 e.g. ~:height 1.5~.)

I also install the Google Noto fonts which have better unicode coverage.
But I find that the characters come out to large,
causing extra space between lines. So scale down the Noto faces.
#+begin_src emacs-lisp
(add-to-list
  'face-font-rescale-alist
  '(".*Noto.*" . 0.8))
#+end_src

Symbola is also a great font to install for coverage,
but the license situation for it is a bit tricky.
I can install it using ~apt~, but it's not available using Guix;
so I've moved away from using it.

I've also found I need to explicitly set some “fallback” fonts.
In particular, for symbols such as Emoji.
#+begin_src emacs-lisp
(set-fontset-font t 'symbol "Noto Color Emoji" nil 'append)
#+end_src

** Line and column information                 :line:

*** Line numbers

As of Emacs 26, ~display-line-numbers-mode~ is the “proper”
way to display line numbers next to a buffer.
(Before 26, ~linum-mode~ was the usual method.)
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src
Line numbers are distruptive in some other modes,
hence why set them to show only in ~text-mode~ and ~prog-mode~ above.
To enable them globally, one would use ~global-display-line-numbers-mode~.

I find it concerning when the width of the column
used for line numbers grows throughout the document;
it makes me think Org mode headlines further down are nested.
Setting ~display-line-numbers-width-start~ causes the system
to count the number of lines when opening a buffer, and
set the minimum width necessary to display all line numbers.
It wastes some screen space, but is good for my sanity.
#+begin_src emacs-lisp
(setq display-line-numbers-width-start t)
#+end_src

*** Display the column number as well as the line number

Toggle on display of the current column number,
alongside the line number, on the modeline.
#+begin_src emacs-lisp
(column-number-mode)
#+end_src

*** Fill column display

Traditionally, it's good style to keep lines under 80 characters wide.
I follow this tradition (though recently some argue the amount should be increased.)

The (as of Emacs 27) built in ~display-fill-column-indicator-mode~ puts a ruler,
by default at 70 characters.
#+begin_src emacs-lisp
(global-display-fill-column-indicator-mode t)
#+end_src

Note that with ~org-indent-mode~, the ruler will be off
by the length of the indentation (i.e. it will be
at line 68 if indented 2 characters, 66 if indented 4, etc).
That's okay; the ruler is there as a reminder more than a firm guideline.

Prior to Emacs 27, ~fci-mode~ could be used for this purpose,
but I found it to cause noticable lag.
Using ~whitespace-mode~ to highlight lines exceeding a certain number
of characters was my preferred approach at that time.

** Themes                                      :theme:

I use Protesilaos Stavrou's [[https://protesilaos.com/modus-themes/][Modus themes]], which
“[conform] with the highest standard for colour contrast
 between background and foreground values”. 
Prior to this I used the ~vibrant~ and ~nord-light~ themes
from [[https://github.com/hlissner/emacs-doom-themes][doom-themes]], but the Modus don't leave me desiring any other themes.
#+begin_src emacs-lisp
(use-package modus-themes)
#+end_src

By default, I prefer the dark ~modus-vivendi~,
but like to toggle between it and the light ~modus-operandi~ at need.
#+begin_src emacs-lisp
(setq my/dark-theme 'modus-vivendi)
(setq my/light-theme 'modus-operandi)

(load-theme my/dark-theme t)
#+end_src

The ~modus-themes-region~ setting
changes the highlighting of selected text.
By default, the background of the selection is gray,
and all text is given the a neutral foreground colour.
Instead, let's use just a tinted background,
and leave the foreground colours as they are.
#+begin_src emacs-lisp
(setq modus-themes-region 'bg-only)
#+end_src

** Highlight matching delimiters               :delimiter:theme:

It's useful to highlight the matching delimiter when the cursor
is on its match, especially when coding in Lisps.
#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src

The Modus themes give various settings for highlighting the match;
the ~intense~ option applies a saturated background colour,
and ~intense-bold~ is the same but it also applies the bold face.
#+begin_src emacs-lisp
(setq modus-themes-paren-match 'intense-bold)
#+end_src

This older code achieved a similar effect by making the background
of the matching delimiter black and the foreground white
(which stood out against my usually rainbow coloured delimiters.)
#+begin_example emacs-lisp
(custom-theme-set-faces
 'user
 '(show-paren-match ((t (:foreground "white"
                         :background "black"
                         :weight ultra-bold)))))
#+end_example

** Kill the open init buffer and reopen it     :cleanup:

To ensure all these cosmetic changes are picked up,
kill my init buffer that we opened earlier and reopen it.
#+begin_src emacs-lisp
(kill-buffer "emacs-init.org")
(find-file my/emacs-init-file)
#+end_src

* Vital non-mode-specific settings

** User information                            :basic:

#+begin_src emacs-lisp
(setq user-full-name "Mark Armstrong")
(setq user-mail-address "markparmstrong@gmail.com")
#+end_src

** Automatically revert unchanged files which change on the disk :vc:

Ideally this helps us avoid conflicts, in case I edit open files elsewhere.
Note reverting will not take place if there are unsaved changes,
so this is relatively safe.
#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src

I do use automatic syncing tools and sometimes work on other systems;
conflicts can still happen if one system is offline or the syncing
gets behind some other way, but with automatic reverts
it's less likely I trip over my own changes.

** Organise automatic backups                  :vc:

(These settings form the basis for
 a crude form of offline version control
 for [[Walking through undo history; undo-propose][undo-propose]]
 and [[Walking through backups; backup-walker][backup-walker]]
 which provide utilities to make use of undos and backups
 as version control.)

Emacs, by default, creates an automatic backup of
the contents of a file before each editing session for the file
See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Backup-Files.html][the manual]]
for all of the details of how and when this is done.

By default, the backup file is placed in the same directory,
and tagged as a backup by appending ~~~ to its name.
This creates a fair bit of clutter;
we can set a location to store all backups to avoid that.
#+begin_src emacs-lisp
(setq backup-directory-alist '(("." . "~/emacs-backups")))
#+end_src

We can use these backups as a crude form of offline version control.
We ask Emacs to number them by setting ~version-control~,
and also to limit the amount of history through ~kept-old-versions~.
Setting ~delete-old-versions~ prevents asking for confirmation
before deleting the excess versions.
#+begin_src emacs-lisp
(setq version-control t)
(setq kept-old-versions 50)
(setq delete-old-versions t)
#+end_src

Do backup files even if they are covered by version control;
we still want this local crude version control
as an added history.
#+begin_src emacs-lisp
(setq vc-make-backup-files t)
#+end_src

As we said above, by default, Emacs makes a new backup
for each editing session on the file.
But since I leave Emacs open almost perpetually,
that can be quite infrequent.
This snippet from
[[https://github.com/alhassy/emacs.d#automatic-backups][Musa Alhassy's init]]
“tricks” Emacs into making a backup each time we save.
#+begin_src emacs-lisp
(defun my/force-backup-of-buffer ()
  "Lie to Emacs, telling it the curent buffer has yet to be backed up."
  (setq buffer-backed-up nil))

(add-hook 'before-save-hook  'my/force-backup-of-buffer)
#+end_src

** Set what characters qualify as delimiters   :delimiter:

*** Angle brackets are not delimiters to me

First, don't treat angle brackets as delimiters; even when writing
HTML or XML, I don't want them to qualify as delimiters for
the purpose of ~show-paren-mode~, ~check-paren~ and ~rainbow-delimiters~.
Treat them as symbols instead (this is the meaning of ~_~ in the
syntax table).
#+begin_src emacs-lisp
(defun my/<>-symbol-syntax ()
  (modify-syntax-entry ?> "_")
  (modify-syntax-entry ?< "_"))
#+end_src

~modify-syntax-table~ works on the current buffer
(unless given a buffer as optional argument)
and so we need to apply those modifications in each buffer.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'my/<>-symbol-syntax)
(add-hook 'prog-mode-hook 'my/<>-symbol-syntax)
(add-hook 'text-mode-hook 'my/<>-symbol-syntax)
#+end_src

The ~org-mode~ function modifies the entries when run,
and ~yankpad~ runs it regularly (albeit in a temporary buffer,
but the modification “leaks”), so we need to undo those
modifications.
#+begin_src emacs-lisp
(defadvice org-mode (after override-<>-syntax activate)
  (my/<>-symbol-syntax))
#+end_src

Side note: I'm honestly uncertain if the “leaking” of
the syntax entry modifications from temporary buffers is a bug.
It's likely just unintuitive behaviour.
It can be observed easily; just modify the entry for i.e. ~<~,
# matching >, just in case
and evaluate
#+begin_example emacs-lisp
(with-temp-buffer
  (org-mode))
#+end_example
and observe your modifications are undone.

*** These unicode characters are delimiters

Do treat these unicode symbols as delimiters.
The first character in each entry means either
- “open delimiter”, if it's a ~(~, or
- “close delimiter”, if it's a ~)~.
The second symbol designates the matching delimiter. 
#+begin_src emacs-lisp
(defun my/unicode-delimiter-syntax ()
  (modify-syntax-entry (string-to-char "⟨") "(⟩")
  (modify-syntax-entry (string-to-char "⟩") ")⟨")
  (modify-syntax-entry (string-to-char "⟪") "(⟫")
  (modify-syntax-entry (string-to-char "⟫") ")⟪")
  (modify-syntax-entry (string-to-char "⟦") "(⟧")
  (modify-syntax-entry (string-to-char "⟧") ")⟦")
  (modify-syntax-entry (string-to-char "⁅") "(⁆")
  (modify-syntax-entry (string-to-char "⁆") ")⁅")
  (modify-syntax-entry (string-to-char "｛") "(｝")
  (modify-syntax-entry (string-to-char "｝") ")｛")
  (modify-syntax-entry (string-to-char "“") "(”")
  (modify-syntax-entry (string-to-char "”") ")“"))
#+end_src

Apply those syntax entry modifications.
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'my/unicode-delimiter-syntax)
(add-hook 'text-mode-hook 'my/unicode-delimiter-syntax)
#+end_src

** Set the tab width                           :space:

I usually use spaces instead of tabs,
but when I do see tabs, I want them to be narrow.
Indentation should not take up large amounts of the screen.
#+begin_src emacs-lisp
(setq-default tab-width 2)
#+end_src

** (Almost) always use spaces instead of tabs  :space:

Many modes check this variable to decide whether to insert
spaces or tabs when pressing the tab key to indent.
I prefer spaces, so set it to ~nil~ so tabs aren't used.
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

Not all modes use this setting; in particular, I've noticed
Go mode does not. But that's appropriate, as the
(strongly recommended) Go formatting style uses tabs.

Notice (elsewhere) the variable ~org-src-tab-acts-natively~;
if this is set to non-nil, then tabs inside ~src~ blocks
will act according to the behaviour of the appropriate mode,
even though Org in general seems to use spacing for indenting
(regardless of the setting of ~indent-tabs-mode~.

** Turn off electric indent mode               :space:

I don't use this or appreciate its interference.
#+begin_src emacs-lisp
(electric-indent-mode -1)
#+end_src

* Vital modes and vital mode-specific settings

** Evil (e-vi-l) mode

I intermittently try to make use of evil mode,
which promises to increase productivity through modal vi-inspired modes,
if one can be thoughtful about ones editing process.

One bit of pre-setup; I don't want evil-mode to override
the behaviour of ~<tab>~ (which is shared with ~C-i~)
during normal (evil) state, as this prevents
cycling of Org section visibilities in normal mode.
#+begin_src emacs-lisp
(setq evil-want-C-i-jump nil)
#+end_src

Install and activate evil.
#+begin_src emacs-lisp
(use-package evil)
(evil-mode 1)
#+end_src

** Org mode                                    :org:

*** Preamble

I use Org for almost everything, and utilise many
of the extras included in ~org-contrib~ (previously ~org-plus-contrib~.)
#+begin_src emacs-lisp
(use-package org
  :ensure org-contrib
  :config
  (require 'ox-extra))
#+end_src

*** Literate programming

**** Execution

By default, Emacs will query whether we /actually/ want to
execute code when we evaluate a code block. Also, it seems to
just /not/ execute code marked for execution during export
in an ~org~ file. I want both of these functionalites,
so I remove the safety.
#+Name: evaluate-no-confirm
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

By default only emacs lisp can be evaluated.
Documentation [[https://orgmode.org/manual/Languages.html][here]].
I activate a few other languages here, and then more
in the [[Programming language modes and mode-specific settings]] section.
:TODO: Move other languages to that section.
#+Name: evaluate-languages
#+begin_src emacs-lisp
(require 'ob-shell)
(require 'ob-haskell)
(require 'ob-latex)
(require 'ob-C)
(require 'ob-ruby)
(require 'ob-plantuml)
(require 'ob-R)
(require 'ob-dot)
(require 'ob-python)
(require 'ob-js)
#+end_src

For shell code, we need to initialise via this function.
See [[https://emacs.stackexchange.com/questions/37692/how-to-fix-symbols-function-definition-is-void-org-babel-get-header][here]].
#+Name: evaluate-shell-init
#+begin_src emacs-lisp
(org-babel-shell-initialize)
#+end_src

PlantUML requires we set the path to the ~.jar~ file.
#+Name: evaluate-plantuml-path
#+begin_src emacs-lisp
(setq org-plantuml-jar-path "/usr/share/java/plantuml.jar")
#+end_src

~ob-typescript~ is [[https://github.com/lurdan/ob-typescript][available]].
#+begin_src emacs-lisp
(use-package ob-typescript)
#+end_src

**** Editing source code

When I choose to edit a source block in a separate buffer,
that source block becomes my main focus.
So, open a new frame (OS window) in which to edit.
Then I can open other material, help buffers, etc.,
without disturbing the window setup around my Org window.
When I finish editing, that frame is killed.
#+begin_src emacs-lisp
(setq org-src-window-setup 'other-frame)
#+end_src
Note, I didn't think I would like the ~other-frame~ option
at all at first, but it grew on me when I realised
it was the best way to ensure that editing source blocks in
a separate buffer would not mess up my window layout
—which ~other-window~ fails to do—
give me the option at least to keep the Org buffer visible
—which ~current-window~ of course disables—
and give me enough room for the source buffer
—which ~split-window-below~ and ~split-window-right~ fail to do
on small screens.

When we open a new window to edit source blocks
the major mode of that window is determined by
the setting for the language in ~org-src-lang-modes~.
Override the setting in that attribute list if you wish to
change the major mode for a particular language.

It's convenient to have ~<tab>~ act as it would in the source language
when editing code blocks in the Org buffer.
#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t)
#+end_src

:TODO:
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
#+end_src

*** Reveal hidden elements if they are edited

Folding a document raises the possibility of accidentally editing
hidden portions. Org provides a way to defend against this:
On making an “invisible” edit, the hidden portion will be unfolded
so the edit can be seen.
#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'show)
#+end_src

** Sending email                               :mail:

:TODO: Check for cleanup of send-mail settings.

#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent)
#+end_src

Whether or not you use Emacs to read your email,
you can use it to send emails with the builtin ~send-mail~.
It can be configured to use your OS default for sending email
(for instance, through a mail program or browser),
or configured to send mail itself (for instance via SMTP).
For convenience, I choose the latter.

I use Gmail exclusively, so the setup is small.
#+begin_src emacs-lisp
(require 'smtpmail)

(setq message-send-mail-function 'smtpmail-send-it
   starttls-use-gnutls t
   smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
   smtpmail-auth-credentials
     '(("smtp.gmail.com" 587 "markparmstrong@gmail.com" nil))
   smtpmail-default-smtp-server "smtp.gmail.com"
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587)
#+end_src

#+begin_src emacs-lisp
(require 'auth-source)
(setq auth-sources '((:source "~/.authinfo.gpg")))
#+end_src

If needed, we can create a queue to allow for sending of email
while offline. See
[[https://www.gnu.org/software/emacs/manual/html_node/smtpmail/Queued-delivery.html][the documentation]].
#+begin_src emacs-lisp
;;(setq smtpmail-queue-mail nil)
#+end_src

After sending an email, kill the buffer.
#+begin_src emacs-lisp
(setq message-kill-buffer-on-exit t)
#+end_src

** Reading email: with mu4e and isync          :mail:

:TODO: Check for cleanup of mu4e settings.

Using Emacs as an email client provides us with powerful text editing
while composing email.

I initially followed the guide
[[https://www.reddit.com/r/emacs/comments/bfsck6/mu4e_for_dummies/][from this reddit post]]
to set it up, but I've customised things heavily at this point.

#+begin_src emacs-lisp
(require 'mu4e)
#+end_src

Run ~mu~ in debug mode, so if something fails we get more information.
#+begin_src emacs-lisp
(setq mu4e-mu-debug t)
#+end_src

*** Basic setup

**** The mail directories

~mu4e~ needs to know where my mail directory lives,
and the paths of certain important mailboxes relative to that.
Note that there should be an archive box here, but I don't make
use of an archive mailbox.
#+begin_src emacs-lisp
(setq
  mu4e-drafts-folder "/Drafts"
  mu4e-sent-folder   "/Sent Mail"
  mu4e-trash-folder  "/Trash")
#+end_src

Previously I would set ~mu4e-maildir~ here;
that is no longer a variable in new versions of ~mu4e~.
Instead the mail directory is taken from ~mu~;
set it with with, e.g., ~mu init --maildir=~/.mail/gmail~.
(Note: it may also be necessary to set the ~--my-address~ flag;
 I'm not certain.)
You can check the setting with
#+begin_example emacs-lisp
(mu4e-root-maildir)
#+end_example

**** Get mail command

I use isync (whose executable is called ~mbsync~) to manage
my local mail directory.

I have two groups set up in my ~mbsyncrc~; one smaller group
of my most important Gmail labels
which synchronises with the remote quickly,
and a larger group of the remaining labels which takes
a fair chunk of time to synchronise.
The ~mu4e~ get mail command uses the former, to ensure
it does not take an excessive amount of time when I manually run it.
#+begin_src emacs-lisp
(setq
  mu4e-get-mail-command "mbsync gmail-quick"
  mu4e-update-interval 300 ;; 5 minutes
  mu4e-headers-auto-update t)
#+end_src

**** Index quietly

Don't take over the minibuffer with a status notification
when indexing messages.
If something's going wrong, flip this setting
as a first step in the diagnosis.
#+begin_src emacs-lisp
(setq mu4e-hide-index-messages t)
#+end_src

**** Change file names when moving emails

To work nicely with ~mbsync~, we should
change the file name when moving mail between mail directories;
otherwise the UID portion of the name becomes stale
and possibly causes issues such as duplicate UIDs
or UIDs out of range.
#+begin_src emacs-lisp
(setq mu4e-change-filenames-when-moving t)
#+end_src

*** Viewing emails

**** Email list

This controls the information shown in the email lists.
- ~:human-date~ will show the time if the email was sent today
  (the alternative, ~:date~, would not).
- ~:from-or-to~ is a special field that will show the sender if it was not me;
  otherwise it will show the recipient.
#+begin_src emacs-lisp
(setq mu4e-headers-fields
  '((:date       . 22)
    (:flags      . 6)
    (:from-or-to . 22)
    (:subject    . nil)))
#+end_src

#+begin_src emacs-lisp
(setq mu4e-headers-date-format "%d %b/%y, %a, %R")
#+end_src

Don't organise by threads; I find organising by date preferable.
#+begin_src emacs-lisp
(setq mu4e-headers-show-threads nil)
#+end_src
This can be toggled with ~P~ in the email list.

By default, related mail is also included; for instance,
if I reply to a message in a list, the reply will show up in the list.
I find this unintuitive, especially since I don't organise by threads.
#+begin_src emacs-lisp
(setq mu4e-headers-include-related nil)
#+end_src

Use fancy characters, including unicode,
for the flags and marks in the email list.
#+begin_src emacs-lisp
(setq mu4e-use-fancy-chars t)
#+end_src

Let's set the symbols used for the above ourselves.
This list originated from a
[[https://github.com/djcb/mu/issues/733][GitHub issue discussion]].
#+begin_src emacs-lisp
(setq
  mu4e-headers-draft-mark     '("D" . "📝 ") ;; ✒ ✏
  mu4e-headers-flagged-mark   '("F" . "🏴 ")
  mu4e-headers-new-mark       '("N" . "★ ")
  mu4e-headers-passed-mark    '("P" . "→ ") ;; ↪
  mu4e-headers-replied-mark   '("R" . "← ")
  mu4e-headers-seen-mark      '("S" . "") ;; ✓ 🗸 ✔
  mu4e-headers-trashed-mark   '("T" . "✗ ") ;; 🗑
  mu4e-headers-attach-mark    '("a" . "📎 ")
  mu4e-headers-encrypted-mark '("x" . "🔐 ")
  mu4e-headers-signed-mark    '("s" . "🔏 ")
  mu4e-headers-unread-mark    '("u" . "✉ "))
#+end_src

**** Individual mail

Show images by default, and prefer to use ~imagemagick~ to do so.
#+begin_src emacs-lisp
(setq mu4e-view-show-images t)

(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
#+end_src

Attachments can simply be placed in ~~/Downloads~;
I usually share this directory from ChromeOS, which makes it convenient
to put attachments there (so I can open them in both OSes easily).
#+begin_src emacs-lisp
(setq mu4e-attachment-dir  "~/Downloads")
#+end_src

Show full email addresses when viewing messages.
#+begin_src emacs-lisp
(setq mu4e-view-show-addresses 't)
#+end_src

**** HTML support

Emacs is not the ideal environment to read HTML emails;
for that reason, if there is a plaintext version available,
I prefer to see that first.
#+begin_src emacs-lisp
(setq mu4e-view-prefer-html nil)
#+end_src

If there is no plaintext available, or if the plaintext is unbearable
for any reason, we can open emails in the browser by using
this shortcut.
#+begin_src emacs-lisp
(add-to-list 'mu4e-view-actions
  '("ViewInBrowser" . mu4e-action-view-in-browser) t)
#+end_src

*** Shortcuts to mailboxes and bookmarks

#+begin_src emacs-lisp
(setq mu4e-maildir-shortcuts
    '(("/Inbox"     . ?i)
      ("/Sent Mail" . ?s)
      ("/Desk/Followup"  . ?f)
      ("/Desk/Reference" . ?r)
      ("/Desk/Transient" . ?t)))
#+end_src

Bookmarks can be used from the ~mu4e~ main page,
and are also useful for programmatically jumping to maildirs.
I set up the inbox bookmark in particular to programmatically jump
to the inbox while setting up my mu4e buffer on a new Emacs instance.
#+begin_src emacs-lisp
(mu4e-bookmark-define "maildir:/Inbox" "Inbox" ?i)
#+end_src

*** Maildirs extension to show read/total counts per mail directory

The package ~mu4e-maildirs-extension~ causes the display of
the read/total count for each mail directory in the list.
#+begin_src emacs-lisp
(use-package mu4e-maildirs-extension)

(mu4e-maildirs-extension)
#+end_src

*** Message composition settings

I don't use a signature.
#+begin_src emacs-lisp
(setq mu4e-compose-signature-auto-include nil)
#+end_src

Don't automatically insert line breaks for long lines
in the message buffer! Such settings infuriate me.
#+begin_src emacs-lisp
(add-hook 'mu4e-compose-mode-hook 'turn-off-auto-fill)
#+end_src

**** Contacts

I've had problems where contact completion breaks.
For the moment, I make sure that the contacts are requested
from ~mu~ upon starting Emacs.
This function in particular was undefined on one of my systems,
so first check it is defined as a function.
#+begin_src emacs-lisp
(when (fboundp 'mu4e~request-contacts)
  (mu4e~request-contacts))
#+end_src

Note that the contacts are stored in a hash table,
and so I am unsure of how to actually see them in Emacs.

**** Flow

I write emails the way I write all my documents:
trying as best I can to respect a maximum line length of 80 characters.
But even 80 characters can be too wide on some mobile screens,
and when I enter my linebreaks, the receiving client may turn this
#+begin_src text
A line with a number of characters that is possibly too wide for mobile.
Another line of a decent length.
#+end_src
into this
#+begin_src text
A line with a number of characters that is possibly
too wide for mobile.
Another line of a decent length.
#+end_src

One option to solve seems to be to use long paragraphs and to
send messages with ~format=flowed~, which tells the receiving client
to reflow paragraphs as needed.
See for instance [[https://www.emacswiki.org/emacs/FormatFlowed]].
But this has two downsides: I dislike writing long lines,
even with autofill.
And ~format=flowed~ is not supported consistently;
for instance Gmail does not respect it.

I don't have a solution for this potential problem yet,
so I choose to do nothing,
and potentially have my emails flow broken on mobile screens.

# It is useful to reflow my text for the reciever.
# The ~format=flowed~ is supposed to allow the receiving client
# to do this.
# #+begin_src emacs-lisp
# (setq mu4e-compose-format-flowed t)
# #+end_src
# But since some clients don't support ~format-flowed;~ Gmail being
# the notable example, instead reflow paragraphs into long lines,
# which should be broken as needed by the receiver.
# #+begin_src emacs-lisp
# (add-hook 'mu4e-compose-mode-hook (lambda () (use-hard-newlines -1)))
# #+end_src
#
# It's convenient not to reply to myself by default.
# #+begin_src emacs-lisp
# (setq mu4e-compose-dont-reply-to-self t)
# #+end_src

**** HTML support (nothing to see here)

Note that there is a ~org-mu4e~ package that comes with ~mu4e~,
which would allow for sending HTML email using ~mu4e~,
but it is apparently depricated.
The ~org-mime~ package above is probably the correct path
if I ever want to send HTML emails.

**** Changing the from address automatically

I use my personal Gmail to collect all of my emails,
but when replying I like to send back from whichever
account the original mail was sent to.
This hook updates the ~From~ field when replying to
an email sent to one of my other accounts.
It is taken from [[https://www.djcbsoftware.nl/code/mu/mu4e/Compose-hooks.html#Compose-hooks][the ~mu4e~ documentation]],
with a modification to save the existing ~user-mail-address~ so
that it can be reset afterwards.
#+begin_src emacs-lisp
(add-hook 'mu4e-compose-pre-hook
  (defun my/set-from-address ()
    "Set the From address based on the To address of the original."
    (let ((msg mu4e-compose-parent-message))
      (when msg
        (setq my/user-mail-address-backup user-mail-address)
        (setq user-mail-address
          (cond
             ((mu4e-message-contact-field-matches msg :to "armstmp@mcmaster.ca")
               "armstmp@mcmaster.ca")
             ((mu4e-message-contact-field-matches msg :cc "armstmp@mcmaster.ca")
               "armstmp@mcmaster.ca")
             (t
               "markparmstrong@gmail.com")))))))
#+end_src

The ~mu4e-compose-mode-hook~ runs
after the message has been formed.
So we are safe to restore the original ~user-mail-address~.
#+begin_src emacs-lisp
;; Initialise the variable used below.
(setq my/user-mail-address-backup nil)

(add-hook 'mu4e-compose-mode-hook
  (defun my/restore-user-mail-address ()
    "Restore the user-mail-address based on the value
     in my/user-mail-address-backup."
    (when my/user-mail-address-backup
       (setq user-mail-address my/user-mail-address-backup))))
#+end_src

*** Miscellaneous

Don't prompt me upon quitting ~mu4e~.
#+begin_src emacs-lisp
(setq mu4e-confirm-quit nil)
#+end_src

*** Start up mu4e so that mu is running at startup

We start ~mu4e~ here in case, for instance,
we use a bookmark to open a ~mu4e~ buffer
before we've started ~mu4e~ correctly.
Without this, we might get an error asking if we started ~mu4e.~
(In particular, I was encountering a ~root maildir unknown~ error.)
#+begin_src emacs-lisp
(mu4e)
#+end_src

** Agda mode                                   :programming:

:TODO: Check for cleanup of Agda settings.

Agda comes with a tool ~agda-mode~ which can be used to locate
the Elisp files for the ~agda-mode~. It's recommended we
execute ~agda-mode locate~ when starting Emacs,
and load the files it reports.
#+begin_src emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
               (shell-command-to-string "agda-mode locate")))
#+end_src

These packages are installed when setting up Agda,
so I simply ~require~ them.
They would be loaded when starting Agda mode,
but I need to load them now
- because I use ~agda2-info-buffer~ to open that buffer on startup,
- because I use ~agda-input~ everywhere, and
#+begin_src emacs-lisp
(require 'agda2-mode)
(require 'agda-input)
#+end_src

*** Command line arguments

Dr. Wolfram Kahl has recommended customising the following settings.
Note that my machine is a virtual machine running on a Chromebook
which, at time of writing (January 2020) has around ~6G~ (out of
the system's total ~8G~) available to it.

That said, my machine is routinely lagging quite badly,
and so I am trying to find the “sweet spot”.
#+begin_src emacs-lisp
(setq agda2-program-args '("+RTS" "-M3.0G" "-H0.6G" "-A128M" "-RTS"))
#+end_src

These arguments specify
| ~+RTS~, ~-RTS~ | Flags between these are arguments to the ~ghc~ runtime |
| ~-M[size]~   | Maximum heap size                                    |
| ~-H[size]~   | Suggested heap size                                  |
| ~-A[size]~   | Allocation area size used by the garbage collector   |

Full documentation for the ~ghc~ runtime argumentscan be found [[https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/runtime-control.html][here]].

Additional arguments that may be useful include
| ~-S[file]~ | Produces information about “each and every garbage collection” |
|          | - Outputs to ~stderr~ by default                               |

*** Alternative problem highlighting

I find the background colouring used by Agda for reporting
errors/warnings makes the underlying code too difficult
to read, especially in dark themes.

So I modify the faces Agda defines.
#+begin_src emacs-lisp
(require 'agda2-highlight)
#+end_src

First, we change all uses of background colouring to coloured boxes
instead.
#+begin_src emacs-lisp
;; Change backgrounds to boxes.
(cl-loop for (_ . face) in agda2-highlight-faces
      do (if (string-prefix-p "agda2-" (symbol-name face)) ;; Some non-Agda faces are in the list; don't change them
             (unless (equal face 'agda2-highlight-incomplete-pattern-face) ;; Workaround; this face is not defined in recent versions?
             (set-face-attribute face nil
               :box (face-attribute face :background)
               :background 'unspecified))))
#+end_src

These can also be intrusive in some cases; specifically, for
warnings about pattern matching. So I modify them specifically.
#+begin_src emacs-lisp
;; Coverage warnings highlight the whole function;
;; change the box to an underline to be less intrusive.
(set-face-attribute 'agda2-highlight-coverage-problem-face nil
  :underline (face-attribute 'agda2-highlight-coverage-problem-face :box)
  :box 'unspecified)

;; Deadcode warnings highlight the whole line;
;; change the box to a strikethrough to be less intrusive,
;; as well as thematically appropriate.
(set-face-attribute 'agda2-highlight-deadcode-face nil
  :strike-through (face-attribute 'agda2-highlight-deadcode-face :box)
  :box 'unspecified)

;; Non-definitional pattern matching may be ignored;
;; remove the colouring and just italicise it to be less intrusive.
(set-face-attribute 'agda2-highlight-catchall-clause-face nil
  :box 'unspecified
  :slant 'italic)
#+end_src

This code can be used to test out many of the redefined faces.
#+begin_src agda2
module HighlightTesting where
  open import Data.Nat using (ℕ ; zero ; suc)

  -- Coverage problem, non-definitional pattern matching, dead code.
  bad-pattern-matching : ℕ → ℕ
--bad-pattern-matching suc n   Missing case; other lines marked with coverage problem face
  bad-pattern-matching 0 = 0
  bad-pattern-matching (suc (suc 0)) = 0
  bad-pattern-matching (suc (suc n)) = 0 -- Non-definitional case (maybe use CATCHALL pragma?).
  bad-pattern-matching 0 = 0 -- Dead code.

  -- Non-terminating
  ∞? : ℕ
  ∞? = suc ∞?

  -- Unsolved meta warnings
  fail-to-solve-meta : ℕ
  fail-to-solve-meta = has-a-meta
    where
      has-a-meta : {n : ℕ} → ℕ
      has-a-meta = 0

  -- Shadowing in telescope
  shadowing-variable : (x : ℕ) → (x : ℕ) → ℕ
  shadowing-variable x y = x

  -- Missing function definition
  has-no-definition : Set

  data unpositive-type : Set where
    bad : (unpositive-type → ℕ) → unpositive-type
#+end_src

*** Add unicode characters to Agda's translations

**** Punctuation and parentheses

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '(";;" "﹔"))
(add-to-list 'agda-input-user-translations '(";;" "⨾"))
(add-to-list 'agda-input-user-translations '("|" "❙"))
(add-to-list 'agda-input-user-translations '("st" "•"))
(add-to-list 'agda-input-user-translations '("{" "｛"))
(add-to-list 'agda-input-user-translations '("}" "｝"))
(add-to-list 'agda-input-user-translations '("{" "⁅"))
(add-to-list 'agda-input-user-translations '("}" "⁆"))
(add-to-list 'agda-input-user-translations '("..." "…"))
#+end_src

**** Arrows

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("pto" "⇀"))
(add-to-list 'agda-input-user-translations '("into" "↪"))
(add-to-list 'agda-input-user-translations '("onto" "↠"))
(add-to-list 'agda-input-user-translations '("conv" "↓"))
(add-to-list 'agda-input-user-translations '("=v" "⇓"))
(add-to-list 'agda-input-user-translations '("eval" "⇓"))
#+end_src

**** Correct mistakes on subscripts/superscripts

I often accidentally hold the shift key for too long when entering
subscripts and superscripts; these translations account for that.

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("^!" "¹"))
(add-to-list 'agda-input-user-translations '("^@" "²"))
(add-to-list 'agda-input-user-translations '("^#" "³"))
(add-to-list 'agda-input-user-translations '("^$" "⁴"))
(add-to-list 'agda-input-user-translations '("^%" "⁵"))
(add-to-list 'agda-input-user-translations '("^^" "⁶"))
(add-to-list 'agda-input-user-translations '("^&" "⁷"))
(add-to-list 'agda-input-user-translations '("^*" "⁸"))
(add-to-list 'agda-input-user-translations '("^(" "⁹"))
(add-to-list 'agda-input-user-translations '("^)" "⁰"))
(add-to-list 'agda-input-user-translations '("_!" "₁"))
(add-to-list 'agda-input-user-translations '("_@" "₂"))
(add-to-list 'agda-input-user-translations '("_#" "₃"))
(add-to-list 'agda-input-user-translations '("_$" "₄"))
(add-to-list 'agda-input-user-translations '("_%" "₅"))
(add-to-list 'agda-input-user-translations '("_^" "₆"))
(add-to-list 'agda-input-user-translations '("_&" "₇"))
(add-to-list 'agda-input-user-translations '("_*" "₈"))
(add-to-list 'agda-input-user-translations '("_(" "₉"))
(add-to-list 'agda-input-user-translations '("_)" "₀"))
#+end_src

**** Emoticons

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '(":)" "😀"))
(add-to-list 'agda-input-user-translations '("grin" "😀"))
(add-to-list 'agda-input-user-translations '("Grin" "😁"))
(add-to-list 'agda-input-user-translations '("meh" "😐"))
(add-to-list 'agda-input-user-translations '("sad" "🙁"))
(add-to-list 'agda-input-user-translations '("gah" "😵"))
(add-to-list 'agda-input-user-translations '("yes" "✔"))
(add-to-list 'agda-input-user-translations '("no" "❌"))
#+end_src

😀 😁 😐 🙁 😵

**** Better access to prime symbols

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("''" "″"))
(add-to-list 'agda-input-user-translations '("'''" "‴"))
(add-to-list 'agda-input-user-translations '("''''" "⁗"))
#+end_src

**** Small, halfwidth and fullwidth math symbols

These can be useful where use of the normal symbols
is restricted; for instance, in ~ditaa~ diagrams many
of them have special meaning.
#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("s*" "﹡"))
(add-to-list 'agda-input-user-translations '("s+" "﹢"))
(add-to-list 'agda-input-user-translations '("s-" "﹣"))
(add-to-list 'agda-input-user-translations '("s<" "﹤"))
(add-to-list 'agda-input-user-translations '("s>" "﹥"))
(add-to-list 'agda-input-user-translations '("s=" "﹦"))
(add-to-list 'agda-input-user-translations '("s\\" "﹨"))
(add-to-list 'agda-input-user-translations '("f+" "＋"))
(add-to-list 'agda-input-user-translations '("f<" "＜"))
(add-to-list 'agda-input-user-translations '("f=" "＝"))
(add-to-list 'agda-input-user-translations '("f>" "＞"))
(add-to-list 'agda-input-user-translations '("f\\" "＼"))
(add-to-list 'agda-input-user-translations '("f^" "＾"))
(add-to-list 'agda-input-user-translations '("f|" "｜"))
(add-to-list 'agda-input-user-translations '("f~" "～"))
(add-to-list 'agda-input-user-translations '("fnot" "￢"))
(add-to-list 'agda-input-user-translations '("h<-" "￩"))
(add-to-list 'agda-input-user-translations '("hu" "￪"))
(add-to-list 'agda-input-user-translations '("h->" "￫"))
(add-to-list 'agda-input-user-translations '("hd" "￬"))
#+end_src

**** Other

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("op" "⊕"))
(add-to-list 'agda-input-user-translations '("^<" "﹤"))
(add-to-list 'agda-input-user-translations '("d<" "⪡"))
(add-to-list 'agda-input-user-translations '("powset" "℘"))
(add-to-list 'agda-input-user-translations '("X" "⨉"))
;; Lunate sigmas
(add-to-list 'agda-input-user-translations '("Ls" "ϲ"))
(add-to-list 'agda-input-user-translations '("LS" "Ϲ"))
#+end_src

This Yi script character for the syllable “git” I use
as a shorthand for “git” (the version control software)
in my tab names.
#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("git" "ꇚ"))
#+end_src

**** Activate the new additions

#+begin_src emacs-lisp
(agda-input-setup)
#+end_src

*** Activate Agda input mode in text, prog and artist modes

Agda input mode makes it extremely easy to use unicode in documents,
something I strongly prefer to do.
When I can use symbols directly, instead of (for instance)
LaTeX commands, it makes my plaintext far more readable.

So, let's enable Agda input mode in most instances.
#+begin_src emacs-lisp
(add-hook 'text-mode-hook
       (lambda () (set-input-method "Agda")))
(add-hook 'prog-mode-hook
       (lambda () (set-input-method "Agda")))
(add-hook 'artist-mode-hook
       (lambda () (set-input-method "Agda")))
#+end_src

*** Org Agda mode

Org-Agda mode is a Polymode Musa and I created
for working on literate Agda documents written in Org mode.
[[https://github.com/alhassy/org-agda-mode]]

We need to install Polymode.
#+begin_src emacs-lisp
(use-package polymode)
#+end_src

#+begin_src emacs-lisp
(require 'org-agda-mode)
#+end_src

** System package management

:TODO:

Note that this depends upon the ~geiser~ and ~geiser-guile~ packages.
#+begin_src emacs-lisp
(use-package guix)
#+end_src

* Keybindings

I make use of ~general~ to organise keybindings.
#+begin_src emacs-lisp
(use-package general)
#+end_src

** General definers

You can use ~general-define-key~ directly to define shortcuts,
ideally using the keyword argument ~:prefix~ to avoid repeating
prefixes, but if you are (even only possibly)
using a prefix several times,
it's better to create a custom function to use instead of
~general-define-key~.

Setting ~:keymaps~ to ~'override~ ensures that no package will
override my shortcuts.

#+begin_src emacs-lisp
(general-create-definer general-main-define-key
  :prefix "C-c"
  :keymaps 'override)

(general-create-definer general-appearance-define-key
  :prefix "C-c a"
  :keymaps 'override)

(general-create-definer general-buffer-define-key
  :prefix "C-c b"
  :keymaps 'override)

(general-create-definer general-window-define-key
  :prefix "C-c w"
  :keymaps 'override)

(general-create-definer general-tab-define-key
  :prefix "C-c t"
  :keymaps 'override)

(general-create-definer general-dired-define-key
  :prefix "C-c d"
  :keymaps 'override)

(general-create-definer general-shell-define-key
  :prefix "C-c s"
  :keymaps 'override)

(general-create-definer general-project-define-key
  :prefix "C-c p"
  :keymaps 'override)

(general-create-definer general-other-package-define-key
  :prefix "C-c o"
  :keymaps 'override)
#+end_src

** Invoke processes

*** imenu                                     :movement:

#+begin_src emacs-lisp
(general-main-define-key
  "i" 'counsel-imenu)
#+end_src

*** avy                                       :movement:

#+begin_src emacs-lisp
(general-main-define-key
  "j" 'avy-goto-char-timer)
#+end_src

*** treemacs

#+begin_src emacs-lisp
(general-project-define-key
  "t" 'treemacs)
#+end_src

*** yankpad                                   :completion:

#+begin_src emacs-lisp
(general-main-define-key
  "f" 'yankpad-expand)

(general-other-package-define-key
  "y i" 'yankpad-insert
  "y m" 'yankpad-map
  "y r" 'yankpad-reload)
#+end_src

*** dired

**** Jumping to specific files

These are not properly ~dired~ shortcuts, but some files
I open often enough to want a direct shortcut.
#+begin_src emacs-lisp
(general-dired-define-key
  "s" '(:ignore t
        :which-key "scratch buffers")
  "sa" '((lambda () (interactive)
           (find-file "~/Dropbox/McMaster/Agda/agda-scratch.agda"))
         :which-key "agda scratch")
  "so" '((lambda () (interactive)
           (find-file "~/logs/scratch/org-scratch.org"))
         :which-key "org scratch")
  "e" '((lambda () (interactive)
           (find-file "~/dotfiles/emacs/emacs-init.org"))
         :which-key "emacs init"))
#+end_src

**** Jumping to directories

I use shortcuts to jump to frequently used directories in ~dired~
(from any buffer, not just while in ~dired~).

Some times it is convenient to use a different function to
invoke ~dired~; in particular, in the past,
I used ~dired-single~ with the invokation ~dired-single-magic-buffer~,
in order to avoid having multiple ~dired~ buffers created.
This turned out to be detrimental once I started keeping
multiple ~dired~ windows open in different tabs.
#+begin_src emacs-lisp
(defun my-dired-invocation (directory)
  "My custom dired invocation.
   It will use my special “magic buffer” for browsing."
  (dired directory))
#+end_src

#+begin_src emacs-lisp
(general-dired-define-key
  "c" '((lambda () (interactive)
          (my-dired-invocation default-directory))
        :which-key "current")
  "/" '((lambda () (interactive)
          (my-dired-invocation "/"))
        :which-key "root")
  "h" '((lambda () (interactive)
          (my-dired-invocation "~"))
        :which-key "home")
  "~" '((lambda () (interactive)
          (my-dired-invocation "~"))
        :which-key "home")
  "a" '((lambda () (interactive)
          (my-dired-invocation "~/@"))
        :which-key "aliases")
  "@" '((lambda () (interactive)
          (my-dired-invocation "~/@"))
        :which-key "aliases")
  "d" '((lambda () (interactive)
          (my-dired-invocation "~/dotfiles/"))
        :which-key "dotfiles")
  "D" '((lambda () (interactive)
          (my-dired-invocation "~/Downloads/"))
        :which-key "downloads")
  "l" '((lambda () (interactive)
          (my-dired-invocation "~/logs/"))
        :which-key "logs")
  "r" '((lambda () (interactive)
          (my-dired-invocation "~/reading/"))
        :which-key "reading")
  "p" '((lambda () (interactive)
          (my-dired-invocation "~/projects/"))
        :which-key "projects")
  "t" '((lambda () (interactive)
          (my-dired-invocation "~/teaching/"))
        :which-key "teaching")
  "T" '((lambda () (interactive)
          (my-dired-invocation "~/projects/agda-computability"))
        :which-key "thesis"))
#+end_src

*** eshell

:TODO: This will not work if ~eshell~ instances are created without this shortcut. Instead I should count the number of shell buffers existing?
#+begin_src emacs-lisp
(general-shell-define-key
  "s" 'eshell)

(setq my/eshell-counter 0)
(general-shell-define-key
  "n" '((lambda () (interactive)
          (setq my/eshell-counter (+ 1 my/eshell-counter))
          (eshell my/eshell-counter))
        :which-key "new eshell"))
#+end_src

*** magit                                     :vc:

#+begin_src emacs-lisp
(general-main-define-key
  "g" 'magit-status)
#+end_src

*** mu4e                                      :mail:

#+begin_src emacs-lisp
(general-main-define-key
  "m" 'mu4e)
#+end_src

With insight on performing the buffer kill action
after the asynchronous
shell command finishes from [[https://emacs.stackexchange.com/questions/42172/run-elisp-when-async-shell-command-is-done][here]].
See the ~kill-buffer-on-process-finish~ definition earlier in this file.
#+begin_src emacs-lisp
(general-other-package-define-key
  "m" '((lambda () (interactive)
          (let* ((output-buffer-name "*mbsync all directories*")
                 (output-buffer (generate-new-buffer output-buffer-name))
                 (process (progn
                         (async-shell-command "mbsync -a" output-buffer)
                         (get-buffer-process output-buffer))))
              (if (process-live-p process)
                  (set-process-sentinel process #'kill-buffer-on-process-finish) 
                (message "mbsync all directories is not running, but I expected it to be!"))))
        :which-key "mbsync all directories"))
#+end_src

*** list-processes

#+begin_src emacs-lisp
(general-other-package-define-key
  "p" 'list-processes)
#+end_src

** Buffer                                      :buffer:

#+begin_src emacs-lisp
(general-buffer-define-key
  "r" '((lambda () (interactive) (revert-buffer () t ()))
        :which-key "revert buffer")

  "u" '(:ignore t
        :which-key "undo actions")
  "u p" '((lambda () (interactive) (undo-propose))
          :which-key "undo-propose")
  "u t" '((lambda () (interactive) (undo-tree-visualize))
          :which-key "undo-tree")

  "t" '((lambda () (interactive) (beginning-of-buffer))
        :which-key "buffer top")
  "b" '((lambda () (interactive) (end-of-buffer))
        :which-key "buffer bottom"))
#+end_src

** Appearance                                  :theme:

#+begin_src emacs-lisp
(general-appearance-define-key
  "t"   '(:ignore t
          :which-key "themes")
  "t t" '((lambda () (interactive) (toggle-my-themes))
          :which-key "toggle theme")
  "t c" '((lambda () (interactive) (disable-all-custom-themes))
          :which-key "clear theme"))
#+end_src

#+begin_src emacs-lisp
(general-appearance-define-key
  "o"   '(:ignore t
          :which-key "org cosmetics")
  "o i"   '(:ignore t
            :which-key "org indent")
  "o i y" '((lambda () (interactive) (org-indent-mode 1))
            :which-key "org indent yes")
  "o i n" '((lambda () (interactive) (org-indent-mode 0))
            :which-key "org indent no"))
#+end_src

These are cosmetics relating to lines in the current buffer.
#+begin_src emacs-lisp
(general-appearance-define-key
  "l"     '(:ignore t
            :which-key "line cosmetics")
  "l n"   '(:ignore t
            :which-key "line numbers")
  "l n y" '((lambda () (interactive) (display-line-numbers-mode 1))
            :which-key "line numbers - yes")
  "l n n" '((lambda () (interactive) (display-line-numbers-mode 0))
            :which-key "line numbers - no")
  "l w"   '(:ignore t
            :which-key "line wrap")
  "l w y" '((lambda () (interactive) (visual-line-mode 1))
            :which-key "yes line wrap")
  "l w n" '((lambda () (interactive) (visual-line-mode 0))
            :which-key "no line wrap"))
#+end_src

Sometimes I need to toggle fontlocking.
#+begin_src emacs-lisp
(general-appearance-define-key
  "f"     '(:ignore t
            :which-key "font lock")
  "f y"   '((lambda () (interactive)
              (font-lock-mode t))
            :which-key "yes font lock")
  "f n"   '((lambda () (interactive)
              (font-lock-mode 0))
            :which-key "no font lock"))
#+end_src

** Window management                           :window:

#+begin_src emacs-lisp
(general-window-define-key
  "<right>" '((lambda () (interactive) (windmove-right))
              :which-key "move focus right")
  "<left>"  '((lambda () (interactive) (windmove-left))
              :which-key "move focus left")
  "<up>"    '((lambda () (interactive) (windmove-up))
              :which-key "move focus up")
  "<down>"  '((lambda () (interactive) (windmove-down))
              :which-key "move focus down"))
#+end_src

Also, let's add a shortcut to jump right to the minibuffer,
assuming it is active.
The space key is low and wide, just like the minibuffer,
so it seems a natural choice.
#+begin_src emacs-lisp
(defun switch-to-minibuffer-window ()
    "Switch to the minibuffer window, if it's active.
     Otherwise do nothing."
    (interactive)
    (when (active-minibuffer-window)
        (select-window (active-minibuffer-window))))

(general-window-define-key
  "SPC" '((lambda () (interactive) (switch-to-minibuffer-window))
              :which-key "move focus to minibuffer"))
#+end_src

#+begin_src emacs-lisp
(general-window-define-key
  "f"  '((lambda () (interactive) (other-frame 1))
         :which-key "other frame")
  
  "["  'winner-undo
  "]"  'winner-redo

  "-"     '((lambda () (interactive) (shrink-window 5))
            :which-key "shrink window")
  "="     '((lambda () (interactive) (enlarge-window 5))
            :which-key "enlarge window")
  "_"     '((lambda () (interactive) (shrink-window 999))
            :which-key "minimise window")
  "+"     '((lambda () (interactive) (enlarge-window 999))
            :which-key "maximise  window"))
#+end_src

** Tab management                              :tab:

#+begin_src emacs-lisp
  (general-tab-define-key
    "r" 'tab-rename
    "k" 'tab-close
    "n" 'tab-new

    "<right>" 'tab-next
    "<left>"  'tab-previous
    "<down>"  'tab-recent
    "<up>"    'tab-undo
    "S-<right>" '((lambda () (interactive) (tab-move 1))
                :which-key "move tab to left")
    "S-<left>"  '((lambda () (interactive) (tab-move -1))
                :which-key "move tab to right")

    "1" (lambda () (interactive) (tab-select 1))
    "2" (lambda () (interactive) (tab-select 2))
    "3" (lambda () (interactive) (tab-select 3))
    "4" (lambda () (interactive) (tab-select 4))
    "5" (lambda () (interactive) (tab-select 5))
    "6" (lambda () (interactive) (tab-select 6))
    "7" (lambda () (interactive) (tab-select 7))
    "8" (lambda () (interactive) (tab-select 8))
    "9" (lambda () (interactive) (tab-select 9))
    "0" (lambda () (interactive) (tab-select 10))
    "-" (lambda () (interactive) (tab-select 11))
    "=" (lambda () (interactive) (tab-select 12)))
#+end_src

** Counsel                                     :completion:

#+begin_src emacs-lisp
(general-main-define-key
  "y" 'counsel-yank-pop)
#+end_src

** Company                                     :completion:

#+begin_src emacs-lisp
(general-main-define-key
  "c" 'company-manual-begin)
#+end_src

** Other

I like dad jokes, and occasionally like to torture those around me
without leaving me work environment 😀.
#+begin_src emacs-lisp
(use-package dad-joke)
(general-other-package-define-key
  "j" 'dad-joke)
#+end_src

* Intermediate cosmetics

** Whitespace display                          :space:

*** Tabs

I usually use spaces rather than tabs,
so I use ~whitespace-mode~ to alert me to the presence of tabs.
#+begin_src emacs-lisp
(global-whitespace-mode t)
#+end_src

Adding ~faces~ to ~whitespace-style~ enables the use of faces
to visualise whitespace.
We then add more values to specify what kinds of whitespace
are visualised with faces; for instance, ~tabs~ to visualise tabs.
Adding ~tab-mark~ visualises tabs
by changing the display table to show a character at the
location of the tab.
#+begin_src emacs-lisp
(setq whitespace-style '(face tabs tab-mark))
#+end_src

I set the face for tabs to make the tab marks fainter;
together with the different foreground and background colouring
for tabs set by the ~tabs~ entry above, this helps them fade
into the background (but still be noticable compared to spaces).
#+begin_src emacs-lisp
(set-face-attribute
  'whitespace-tab
  nil ;; all frames
  :weight     'ultra-light)
#+end_src

*** Non-breaking spaces

Since I use unicode regularly, I do use non-breaking spaces
occasionally, especially for intraperiodic spaces, e.g.,
following ~Dr.~ or ~Mrs.~.
I do want to be aware of those spaces; thankfully there is
a face for that.
#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(nobreak-space ((t (:underline t)))))
#+end_src

*** Deprecated whitespace highlighting

I previously used ~whitespace-style~ to highlight
trailing whitespace; however, I find this feature intrusive,
so I avoid it.

If it is wanted later, then I should add to the list
#+begin_example emacs-lisp
(face trailing)
#+end_example
We need to add ~face~ to the list, to enable using faces
to highlight whitespace.

Note there is no way to visualise spaces only at the end of lines;
The visualisation is done by changing the display table,
and there is no ability to do so only in particular places.
Otherwise I would use that rather than highlighting.

** Rainbow delimiters                          :delimiter:

Above, I have settings for highlighting the delimiter
matching the one under the cursor.

The package ~rainbow-delimiters~ goes ones step further than
highlighting the delimiter matching the one under cursor;
it makes the matching of all delimiters
obvious by using various colours.
Each level of nesting uses a different colour.
#+begin_src emacs-lisp
(use-package rainbow-delimiters)
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
(add-hook 'text-mode-hook #'rainbow-delimiters-mode)
#+end_src

One potential downside of ~rainbow-delimiters~ is that when
delimiter matching fails for reasons out of our control,
it can make the appearance of delimiters very poor in that buffer.

# Commented opening paren to match unmatched closing one in example below (
For instance, if we write a list using a parenthese after each label,
1) such as here,
those parentheses will be unmatched, and will be highlighted in red.

Worse, in some modes, it is not clear which delimiters
should be matched and which not.
In particular, delimiters which occur inside strings
in code should not be considered as proper delimiters,
and programming modes usually set up this behaviour.
But Org mode source blocks for those languages do not inherit
that behaviour, so such delimiters are not given any special status
and will be highlighted.

If we are working on another's Org code, there is little we can do
to alleviate this.
In my own Org code, I tend to insert comments to match the delimiters,
or avoid cases where this can occur (such as using periods after
the labels in lists.)

For an example of this, see my settings for the Org emphasis
regular expressions, which require some commented out
delimiters to avoid breaking all delimiter matching
later in this file.

** Tab-bar                                     :tab:

I make use of ~tab-bar-mode~.
But note that these are not like tabs in most other applications,
where you have a tab for each open file!
That functionality is provided by ~tab-line-mode~,
not ~tab-bar-mode~, and I find it unnecessary in Emacs;
buffer switching and handling mechanisms are sufficient.

~tab-bar-mode~ tabs instead act as saved window configurations.
#+begin_src emacs-lisp
(tab-bar-mode)
#+end_src

Show numbers on the tabs, so I can easily change tabs
using keyboard shortcuts by number.
#+begin_src emacs-lisp
(setq tab-bar-tab-hints 't)
#+end_src

Remove the close buttons on tabs.
Hitting them by mistake is annoying,
and I can close tabs by other commands easily enough.
#+begin_src emacs-lisp
(setq tab-bar-close-button-show nil)
#+end_src

Setting the ~tab-bar-format~ controls the order
in which elements appear on the tab bar.
We stick to just the tabs
(with group support, so if we group tabs
 the groups with collapse/expand),
and any global information (which would normally be shown in the modeline)
on the right side after a gap.
This includes the time, if we enable ~display-time-mode~.
#+begin_src emacs-lisp
(setq tab-bar-format
  '(tab-bar-format-tabs-groups
    tab-bar-format-align-right
    tab-bar-format-global))
#+end_src

** A more noticable divider between windows    :window:

One problem with a fill column ruler is that it can seem like
it is the divider between windows.

For that reason, I like to have a more noticable divider
between windows. ~window-divider-mode~ provides this.
#+begin_src emacs-lisp
(window-divider-mode)
#+end_src

** Dim buffers when not in use                 :buffer:

The package ~dimmer~ will dim inactive windows to emphasise which
window has focus.
See its [[https://github.com/gonewest818/dimmer.el][Github page]].
#+begin_src emacs-lisp
(use-package dimmer)
#+end_src

Turn ~dimmer-mode~ on when Emacs starts.
#+begin_src emacs-lisp
(dimmer-mode)
#+end_src

Don't dim ~which-key~ and ~helm~ buffers.
#+begin_src emacs-lisp
(dimmer-configure-which-key)
(dimmer-configure-helm)
#+end_src

We can adjust the ~:foreground~ colours, the ~:background~ colours,
or ~:both~. With a dark theme, adjusting the background causes
the background to become lighter in inactive buffers,
which “looks wrong” (makes them looked like they have focus).
So I set this to just ~:foreground~ (which is the default anyway).
#+begin_src emacs-lisp
(setq dimmer-adjustment-mode :foreground)
#+end_src

I find the default dimming of ~20%~ to be too faint;
it is noticeable when changing windows, but it does not
remain noticeable enough later (e.g. when I look away from Emacs
then look back). Increasing that to ~30%~ seems to be sufficient,
while maintaing the readability of unfocussed buffers.
#+begin_src emacs-lisp
(setq dimmer-fraction 0.3)
#+end_src

Note that by default, all windows will be dimmer when Emacs
notices that it does not have focus in the windowing system.
I like this behaviour; it could be changed by changing
the variable ~dimmer-watch-frame-focus-events~.

The developer of the ~modus~ themes I use recommends
using RGB colour space with ~dimmer~;
they say that colour space “remains faithful
to the hueness of the colours used by the themes.”
#+begin_src emacs-lisp
(setq dimmer-use-colorspace :rgb)
#+end_src

** Kill the open init buffer and reopen it     :cleanup:

To ensure all these cosmetic changes are picked up,
kill my init buffer that we opened earlier and reopen it.
#+begin_src emacs-lisp
(kill-buffer "emacs-init.org")
(find-file my/emacs-init-file)
#+end_src

* Intermediate modes and intermediate mode-specific settings

** Org mode cosmetics                          :org:

**** Indent text based on heading by default

Although it wastes some space, it's generally easier to read
Org files if the contents of a heading are indented
based on the nesting of the heading.
#+begin_src emacs-lisp
(setq org-startup-indented t)
#+end_src

This can be overrode for particular files
by using the ~startup~ setting ~noindent~.
(I.e., put ~#+startup: noindent~ in the file.)

**** Hide emphasis markers by default

Emphasis markers, the markup syntax that
makes particular portions of the text bold, italicized, etc.,
do not generally need to be seen when deiting.
#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

It is convenient to show the emphasis markers around point.
Otherwise it becomes tedious to edit emphasised text.

There have been a couple Reddit posts seeking to solve this problem.
First, [[https://www.reddit.com/r/orgmode/comments/43uuck/][this code]] which doesn't work for all emphasis markers.
#+begin_example emacs-lisp
(defun org-show-emphasis-markers-at-point ()
  (save-match-data
    (if (and (org-in-regexp org-emph-re 2)
             (>= (point) (match-beginning 3))
             (<= (point) (match-end 4))
             (member (match-string 3) (mapcar 'car org-emphasis-alist)))
        (with-silent-modifications
         (remove-text-properties
          (match-beginning 3) (match-beginning 5)
           '(invisible org-link)))
      (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5))))))
#+end_example

Then, [[https://www.reddit.com/r/orgmode/comments/dj5u1y][this more recent code]]
which adds more checks.
However, it seems to lag input a bit?
#+begin_example emacs-lisp
(defun sbr-org-toggle-emphasis-markers-at-point ()
  (interactive)
  (save-match-data
    (when (or (org-in-regexp org-emph-re 2)
              (org-in-regexp org-verbatim-re 2))
      (if (and (>= (point) (match-beginning 3))
               (<= (point) (match-end 4))
               (member (match-string 3) (mapcar 'car org-emphasis-alist))
               (get-text-property (match-beginning 3) 'invisible))
          (with-silent-modifications
            (remove-text-properties
             (match-beginning 3) (match-beginning 5)
             '(invisible org-link)))
        (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5)))))))
#+end_example

This is my attempt, combining the two to some extent.
:TODO: this doesn't always hide the characters after point leaves
#+begin_src emacs-lisp
(defun org-toggle-emphasis-markers-at-point ()
  (save-match-data
    (when (or (org-in-regexp org-emph-re 2)
              (org-in-regexp org-verbatim-re 2)
              (org-in-regexp org-link-any-re 2))
      (if (and (>= (point) (match-beginning 3))
               (<= (point) (match-end 4))
               (member (match-string 3) (mapcar 'car org-emphasis-alist)))
               ;; invisible check?
          (with-silent-modifications
            (remove-text-properties
             (match-beginning 3) (match-beginning 5)
             '(invisible org-link)))
        (apply 'font-lock-flush
          (list (match-beginning 3) (match-beginning 5)))))))
#+end_src

We run the above function after each command in an Org mode buffer.
:TODO: improve this functionality before use.
#+begin_src emacs-lisp
;(add-hook 'org-mode-hook
;  (lambda ()
;    (add-hook 'post-command-hook
;      'org-toggle-emphasis-markers-at-point nil t)))
#+end_src

**** Emphasis marker regexps

We can change the behaviour of Org emphasis markers
in terms of what characters are allowed to occur around
and between them; see 
[[https://emacs.stackexchange.com/questions/41111/][this stack exchange post]]
for a sample setup, and
[[https://emacs.stackexchange.com/questions/13820][this other post]]
which is linked to from the first and which has more details.

Note that these settings are somewhat complicated
by the fact that they are used to construct regular expressions;
I lost a great amount of time to misplaced brackets and braces,
which made Org very confused about what I wanted,
since they were misinterpreted as regular expression syntax.
See my
[[https://stackoverflow.com/q/63805679/2041536][StackOverflow question]] on this.

Everything here must be set when Org is loaded.
#+begin_src emacs-lisp
(with-eval-after-load 'org
#+end_src

Only these characters are allowed to immediately precede
an emphasis character (left outer boundary characters).
Note that, as I am including a dash, it must be the first or final character,
and if including a closing bracket, it must be the first character.
See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Regexp-Special.html#Regexp-Special][Special Characters in Regular Expression]].
#+begin_src emacs-lisp
  (setcar org-emphasis-regexp-components
    (concat
      ;; All whitespace characters.
      "[:space:]"
      (string
        ;; Opening delimiters; the comments prevent check-parens from getting mad 😀.
        ?\( ;;)
        ?\{ ;;}
        ?“  ;;”
        ?\[ ;;]
        ;; Dashes
        ?— ?– ?-))) ;; Do not move the dash. It will break the regexp.
#+end_src

Only these characters are allowed to immedately follow
an emphasis character (right outer boundary characters).
#+begin_src emacs-lisp
  (setcar (nthcdr 1 org-emphasis-regexp-components)
    (concat
      (string ;[
         ?\]) ;; Do not move the bracket. It will break the regexp.
      ;; All whitespace characters.
      "[:space:]"
      (string
        ;; Closing delimiters, with matching comments as above.
            ;;(
        ?\) ;;{
        ?\} ;;“
        ?”
        ;; Single quote
        ?'
        ;; Punctuation
        ?. ?? ?! ?, ?\; ?:
        ;; Dashes
        ?– ?— ?-))) ;; Do not move the dash. It will break the regexp.
#+end_src

Any characters are allowed as inner boundary characters,
/except/ for those listed here.
#+begin_src emacs-lisp
  (setcar (nthcdr 2 org-emphasis-regexp-components)
    "[:space:]")
#+end_src

Any characters are allowed between the inner border characters.
(The regular expression ~.~ matches any character).
#+begin_src emacs-lisp
  (setcar (nthcdr 3 org-emphasis-regexp-components)
    ".")
#+end_src

Only one newline allowed, though.
#+begin_src emacs-lisp
  (setcar (nthcdr 4 org-emphasis-regexp-components) 1)
#+end_src

Now we update the setting.
#+begin_src emacs-lisp
  (org-set-emph-re
    'org-emphasis-regexp-components
    org-emphasis-regexp-components))
#+end_src
NOTE the extra closing parenthesis to end the ~with-eval-after-load~!

***** Test it out

Here are tests of all the ~pre~ and ~post~ values at time of writing.
#+begin_src org
 *test*
(*test*
)
[*test*
]
{*test*
}
“*test*
”
-*test*
–*test*
—*test*

*test* ;
(
*test*)
[
*test*]
{
*test*}
“
*test*”
*test*-
*test*–
*test*—
*test*.
*test*?
*test*!
*test*,
*test*;
*test*:
#+end_src

**** Highlight math mode blocks

Org mode supports some LaTeX content inline.
In particular, we can use math mode syntax ~$…$~ and
subscripts ~_{…}~ and superscripts ~^{…}~.
We should highlight this content to emphasis its presence.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
#+end_src

:TODO: What does ~entities~ refer to here?

**** Pretty bullets

Replace the plain asterisk bullets preceding Org headings
with fancier characters; a collection is used, so that
headings at different levels have different bullets.
#+begin_src emacs-lisp
(use-package org-bullets
  :hook (org-mode . org-bullets-mode))
#+end_src

**** Replace the ellipsis

By default, folded portions of the document are
presented by an (non-unicode) ellipsis. Let's replace that.
#+begin_src emacs-lisp
(setq org-ellipsis " ⮷")
#+end_src

**** Inline images

We can configure Org to automatically inline linked images
when opening documents.
#+begin_src emacs-lisp
(setq org-startup-with-inline-images t)
#+end_src

**** Tag position

By default (as of Org 9.1.9),
tags get shifted to the 77th column.
But this causes blank lines to be inserted
when working on narrower screens.
I bump it down a good bit,
to ensure tags stay away from the right side of the screen.
#+begin_src emacs-lisp
(setq org-tags-column 48)
#+end_src

**** Adjusting image display size

I like to use inline images in Org mode, but of course
I don't want large images to be shown at full size!
Better to err on the side of making images too small,
so set the width of all images to be just 100 pixels.
#+begin_src emacs-lisp
(setq org-image-actual-width 100)
#+end_src

**** Colour-coded source block backgrounds

We can colour the background of Org source blocks
based on the language. Neat!
The nuanced colours of the Modus themes are specifically intended
for this application.
#+begin_src emacs-lisp
(setq org-src-block-faces
  '(;; Lisps
    ("emacs-lisp" modus-themes-nuanced-magenta)
    ("elisp"      modus-themes-nuanced-magenta)
    ("clojure"    modus-themes-nuanced-magenta)

    ;; ML family functional
    ("purescript" modus-themes-nuanced-blue)
    ("elm"        modus-themes-nuanced-blue)
    ("haskell"    modus-themes-nuanced-blue)
    ("scala"      modus-themes-nuanced-blue)
    ("amm"        modus-themes-nuanced-blue)

    ;; Imperative languages
    ("c"          modus-themes-nuanced-green)
    ("javascript" modus-themes-nuanced-green)
    ("ruby"       modus-themes-nuanced-green)
    ("python"     modus-themes-nuanced-green)
    ("sh"         modus-themes-nuanced-green)
    ("bash"       modus-themes-nuanced-green)
    ("zsh"        modus-themes-nuanced-green)
    ("go"         modus-themes-nuanced-green)

    ;; Logical and proof assistants
    ("agda2"      modus-themes-nuanced-cyan)
    ("prolog"     modus-themes-nuanced-cyan)

    ;; Plaintext, data and configuration formats
    ("text"       modus-themes-nuanced-red)
    ("org"        modus-themes-nuanced-red)
    ("html"       modus-themes-nuanced-red)
    ("latex"      modus-themes-nuanced-red)
    ("ditaa"      modus-themes-nuanced-red)
    ("dot"        modus-themes-nuanced-red)

    ;; Configuration and pure data
    ("xml"        modus-themes-nuanced-yellow)
    ("css"        modus-themes-nuanced-yellow)
    ("json"       modus-themes-nuanced-yellow)
    ("conf"       modus-themes-nuanced-yellow)
    ("docker"     modus-themes-nuanced-yellow)
    ("dhall"      modus-themes-nuanced-yellow)
    ("yaml"       modus-themes-nuanced-yellow)
    ("toml"       modus-themes-nuanced-yellow)))
#+end_src

We may need to Org for the changes to take effect.
#+begin_src emacs-lisp
(org-mode-restart)
#+end_src

***** COMMENT Test it out

The built in examples at least use the theme's nuanced colours.
The below examples assume the Modus Vivendi theme.
The Operandi colours are sometimes different.

Nuanced magenta for Lisps.
#+begin_example emacs-lisp
(defun my/cool-message (arg) (message "hello world"))
#+end_example

Nuanced blue for the ML family of functional languages.
#+begin_example purescript
main :: Effect Unit
main = do
  log "Hello World!"
#+end_example

Nuanced green for imperative languages,
including shell languages.
#+begin_example sh
echo "hello world"
#+end_example

Nuanced cyan for logical languages and proof assistants.
#+begin_example agda2
hello world
#+end_example

Nuanced red for HTML, LaTeX, and other languages
intended to produce documents to be read or viewed.
Plaintext and ASCII (or other) drawing languages included here.
#+begin_example html
<p>Hello World</p>
#+end_example

Nuanced yellow for configuration filetypes
and pure data languages, such as XML and JSON.
#+begin_example css
hello {
    world: Red;
}
#+end_example

** Org mode exportation settings               :org:

*** Export in the background

:TODO: This section needs a full cleanup.

Using ~latex-mk~, the export process for LaTeX takes a bit of time.
Tying up emacs during that time is annoying, so set the
export to happen in the background.
This setting can be modified locally in the export dialog frame
if desired by adding ~C-a~ to the export key sequence.
#+begin_src emacs-lisp
; (setq org-export-in-background t)
#+end_src

This works by spawning a new Emacs session in which the file is exported.
By default, that session would use this init file, but that's overkill
and wastes time; most of this init is not relevant for that session.
So, we'll set a different init file, constructed from the relevant
portions of this file.
#+begin_src emacs-lisp
; (setq org-export-async-init-file
;   "~/.config/emacs/org-async-init.el")
#+end_src

Some default settings.
#+begin_src emacs-lisp :noweb yes :tangle ~/.config/emacs/org-async-init.el
;; Org export init, tangled from my Emacs init
(require 'package)
(setq package-enable-at-startup nil)
(package-initialize)

(require 'org)
(require 'ox)
(require 'ox-extra)

(setq org-export-async-debug t)
#+end_src

:TODO: There must be a better way to generate this file.
These settings are from this exporting section.
#+begin_src emacs-lisp :noweb yes :tangle ~/.config/emacs/org-async-init.el
<<export-ignore-headlines>>
<<export-ignore-sections>>
<<export-preserve-indentation>>
<<export-htmlize>>
<<export-preserve-org-links>>
<<export-latex-compiler>>
<<export-latex-process>>
<<export-latex-classes>>
<<export-latex-beamer-classes>>
<<export-latex-minted>>
<<export-latex-hyperref>>
<<export-reveal>>
<<export-reveal-theme>>
<<export-reveal-title>>
<<export-reveal-extra-css>>
<<export-pandoc>>
<<export-headline-ids>>
<<export-sub-superscripts>>
#+end_src

We also need code evaluation settings, as code blocks may need
to be evaluated for export.
#+begin_src emacs-lisp :noweb yes :tangle ~/.config/emacs/org-async-init.el
<<evaluate-no-confirm>>
<<evaluate-languages>>
<<evaluate-ditaa-path>>
<<evaluate-shell-init>>
<<evaluate-plantuml-path>>
#+end_src

*** Ignoring content

**** Headings

Use the ~:ignore:~ tag on headlines to omit the headline when
exporting, but keep its contents.
#+Name: export-ignore-headlines
#+begin_src emacs-lisp
(ox-extras-activate '(ignore-headlines))
#+end_src

Alternatively, use the ~:noexport:~ tag to omit the headline
/and/ its contents.
#+Name: export-ignore-sections
#+begin_src emacs-lisp
;;;; noexport is in the list by default
;; (add-to-list 'org-export-exclude-tags "noexport")
#+end_src

**** Drawers

Ignore all drawers when exporting, by default.
#+begin_src emacs-lisp
(setq org-export-with-drawers nil)
#+end_src

*** Source code block indentation and colouring

I want to preserve my indentation for source code during export.
#+Name: export-preserve-indentation
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

The ~htmlize~ package preserves source code colouring on export to html.
(And presumably does a lot more I am not fully aware of).
#+Name: export-htmlize
#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

Now, since I work with a dark theme (at least most of the time),
the source code colouring ~htmlize~ uses might not show up well
on the typically white background in the exported HTML.
This code from [[https://emacs.stackexchange.com/a/3512/30156][StackExchange]]
removes that problem; use the current background colour when exporting!
#+begin_src emacs-lisp
(defun my-org-inline-css-hook (exporter)
  "Insert custom inline css"
  (when (eq exporter 'html)
    (let ((my-pre-bg (face-background 'default)))
      ;;(setq org-html-head-include-default-style nil)
      (setq org-html-head-extra
            (format "<style>pre.src{background:%s;color:white;} </style>" my-pre-bg)))))

(add-hook 'org-export-before-processing-hook 'my-org-inline-css-hook)
#+end_src

The above was modified to not explicitely disable the default styling
(don't need it in my case, but also don't need to disable it)
and to use ~head-extra~ instead of ~head~, as ~head~ is overwritten
by the themes I use.

Note, if I set ~HTML_HEAD_EXTRA~ in an Org file,
then the background colour setting will be lost!

:TODO: It would be nice to pick up the background colour for that particular language, rather than default; I like the differing colours the Modus theme gives me for source blocks.

*** Don't change Org links to HTML

By default
(see the [[https://orgmode.org/manual/Links-in-HTML-export.html][manual]])
when exporting to HTML, Org will change ~.org~ links to ~.html~.
I don't want this; for instance, when teaching a course,
I like to link to both a generated HTML file and
the original Org source version of notes
(on my generated course homepage).
#+Name: export-preserve-org-links
#+begin_src emacs-lisp
(setq org-html-link-org-files-as-html nil)
#+end_src

If I mean to link to the HTML file, I will do so explicitely.

*** Require braces to denote sub/superscripts

Sometimes I want to export the characters ~_~ or ~^~.
However, Org allows these to be used for LaTeX style sub/superscripts,
so a lone ~_~ will be exported (to LaTeX at least)
as ~\_{}~ (and similarly for a lone ~^~).

In order to avoid this, but still allow for LaTeX style sub/superscripts,
we can use a setting to /require/ that sub/superscripts be enclosed in brackets
(which is my preference in any case).
#+Name: export-sub-superscripts
#+begin_src emacs-lisp
(setq org-export-with-sub-superscripts '{})
#+end_src

*** LaTeX export settings

**** Default LaTeX compiler

I use a lot of unicode, and I find ~xelatex~ and ~lualatex~
handle that more easily than ~pdflatex~.

From my experience so far, they seem pretty interchangable
for my purposes, so the decision of which to use is arbitrary.

Based on [[https://tex.stackexchange.com/questions/36/differences-between-luatex-context-and-xetex][this discussion on Stack Exchange]], LuaTeX seems the more
“up and coming” engine. I've used it for quite a while now,
and have found no problems with it.
#+Name: export-latex-compiler
#+begin_src emacs-lisp
(setq org-latex-compiler "lualatex")
#+end_src

**** LaTeX compilation process

I use ~latexmk~ to automatically run as many passes as needed
to resolve references, etc.
#+Name: export-latex-process
#+begin_src emacs-lisp
(setq org-latex-pdf-process
      '("latexmk -%latex -shell-escape -f %f"))
#+end_src

The flags/format specifiers are
| ~%latex~        | stands in for the latex compiler (defaults to the setting above) |
| ~-f~            | force continued processing past errors                           |
| ~%f~            | stands in for the (relative) filename                            |
| ~-shell-escape~ | necessary to use ~minted~                                          |

**** Custom document classes

I want a ~report~ class that begins with ~chapter~'s, rather than
~part~'s.
#+Name: export-latex-classes
#+begin_src emacs-lisp
(add-to-list
  'org-latex-classes
    '("report-noparts"
      "\\documentclass{report}"
      ("\\chapter{%s}" . "\\chapter*{%s}")
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

Sometimes, for creating slides, ~beamer~ is useful.
(Though I try to avoid it now; it feels low level to me).
#+Name: export-latex-beamer-classes
#+begin_src emacs-lisp
(add-to-list
  'org-latex-classes
    '("beamer"
      "\\documentclass[presentation]{beamer}"
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
#+end_src

**** Use minted for code blocks

First, make sure we load the ~minted~ package.
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist '("newfloat" "minted"))
#+end_src
The ~newfloat~ package can be used with ~minted~ with
a ~newfloat~ option to, for instance, support pagebreaks
in the float. See this StackExchange
[[https://tex.stackexchange.com/questions/254044/][post]]
if you want to set that up.

Now, we tell Org to use a ~minted~ environment,
rather than the default ~verbatim~, for code.
#+begin_src emacs-lisp
(setq org-latex-listings 'minted)
#+end_src

***** Default options for minted

One reason to use ~minted~ or ~listings~ over the simple ~verbatim~ is
that it can put decent-looking linebreaks where necessary
to prevent code running out of the margins.
This is controlled by the ~breaklines~ argument.

Probably there are other options I should add as well.

#+begin_src emacs-lisp
(setq org-latex-minted-options
  '(("breaklines" "true")))
#+end_src

***** Don't box unicode characters

Since I primarily export Agda code, which is full of unicode characters,
and most ~minted~ styles enclose those characters in a red ~fbox~,
I use this hack to disable ~fbox~'s inside ~minted~ environments.
(setq 'org-latex-packages-alist ())

#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist
  "\\makeatletter
\\def\\dontdofcolorbox{\\renewcommand\\fcolorbox[4][]{##4}}
\\AtBeginEnvironment{minted}{\\dontdofcolorbox}
\\makeatother")
#+end_src

#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist '("" "etoolbox"))
#+end_src

***** Treat Agda source as Haskell for listings

Unfortunately, ~minted~ doesn't support Agda,
so we simply have Org tell it that it's Haskell code.
#+begin_src emacs-lisp
(add-to-list 'org-latex-minted-langs '(agda2 "Haskell"))
#+end_src

***** Alternative: use listings in place of minted

As a step between using ~verbatim~ blocks and
using ~minted~ for source code,
we can use the ~listings~ package.

I found that ~listings~ caused odd typesetting of my Agda code;
code was out of order, particularly when using underscores,
and had oddly placed line breaks.
It may have been an issue with treating Agda code as Haskell;
I didn't diagnose much before switching to
using ~minted~ instead.

If the setup is desired, here is how to do it:
#+begin_example emacs-lisp
(setq org-latex-listings t) ;; As opposed to 'minted
(add-to-list 'org-latex-listings-langs '(agda2 "Haskell"))
#+end_example

**** Hyperref setup

The ~LaTeX~ ~hyperref~ package gives us better links.
I don't care for varying link colours, so I set them all to
the common blue colour.
#+Name: export-latex-hyperref
#+begin_src emacs-lisp
(setq org-latex-hyperref-template
  "\\hypersetup{
   pdfauthor={%a},
   pdftitle={%t},
   pdfkeywords={%k},
   pdfsubject={%d},
   pdfcreator={%c},
   pdflang={%L},
   colorlinks,
   linkcolor=blue,
   citecolor=blue,
   urlcolor=blue
   }
"
)
#+end_src

**** More flexible tables

Adding the ~tabularx~ package as a dependency gives us
more flexible tables when we need them.
See [[https://orgmode.org/manual/Tables-in-LaTeX-export.html][the Org manual]]
for information on how to export tables as ~tabularx~ tables.
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist
  '("" "tabularx"))
#+end_src

**** Image handling

I prefer to be explicit about how images are handled during export.
So, I turn off some defaults of how they are handled in LaTeX.

In particular, the LaTeX export backend by default
wraps images in ~center~ blocks; but this breaks the ability
to include images in tables.
#+begin_src emacs-lisp
(setq org-latex-images-centered nil)
#+end_src

:TODO: Is this setting wise?
#+begin_src emacs-lisp
(setq org-latex-image-default-width nil)
#+end_src

*** HTML export settings

**** Modify the postamble

By default, ~org-html-postamble~ is set to ~auto~.
We overwrite that to ~t~ so that the postamble is constructed
following the ~org-html-postamble-format~, which we set.
#+begin_src emacs-lisp
(setq org-html-postamble t)

(setq org-html-postamble-format
 '(("en"
    "<p class=\"author\">Author: %a</p>
     <p class=\"author\">Contact: %e</p>
     <p class=\"date\">Original date: %d</p>
     <p class=\"date\">Last updated: %C</p>
     <p class=\"creator\">Created using %c</p>
     <p class=\"validation\">%v</p>")))
#+end_src

**** Ensure useful HTML anchors

This code snippet is borrowed from Musa's
[[https://github.com/alhassy/emacs.d/#Ensuring-Useful-HTML-Anchors][init]].

#+begin_quote
Upon HTML export, each tree heading is assigned
an ID to be used for hyperlinks.
Default IDs are something like org1957a9d,
which does not endure the test of time:
Re-export will produce a different id.
Here's a rough snippet to generate IDs from headings,
by replacing spaces with hyphens, for headings without IDs.
#+end_quote

I have made several edits.
- Begin by deleting all custom IDs which have apparently
  been added by this process.
- At each step, get the list of custom IDs from earlier in the file;
  if the ID we intend to add at this step is in that list,
  add a counter to the end, incrementing it until the ID is unique.
- Do not assign the custom id if
  the heading is tagged with ~:noexport:~ or ~:ignore:~;
  there's no point to adding one if the heading is not included
  in the export.
#+Name: export-headline-ids
#+begin_src emacs-lisp
(defun my/ensure-headline-ids (&rest _)
  "Org trees without a :CUSTOM_ID: property have the property
   set to be their headline.

   Trees whose headline are tagged with :ignore:
   are not given an ID.

   Trees whose headline are tagged with :noexport:
   and any subtrees of those trees are not given an ID.

   A prefix is used to identify IDs which were set by this process,
   so they can be recreated in case their headline changes.
   A postfix counter is used to prevent the case where
   trees cannot be linked to because they happen to share
   their heading with earlier trees.
  "
  (interactive)
  (let ((generated-ids ())
        (prefix "org-anchor-"))
    (cl-flet ((append-counter (x n) (concat x "^" (number-to-string n))))
      (org-map-entries
       (lambda ()
         (let* ((heading-components (org-heading-components))
                (headline (nth 4 heading-components))       
                (tags     (nth 5 heading-components)))
           (if (and tags (string-match-p (regexp-quote ":noexport:") tags))
             ;; This heading is tagged as noexport.
             ;; Set org-map-continue-from to next heading at this level.
             ;; (Just moving to the next heading would not suffice;
             ;;  children of this heading are also not exported.)
             (setq org-map-continue-from (progn (org-goto-sibling)
                                                (line-beginning-position)))
             ;; Otherwise, check if this heading is tagged as ignore.
             (unless (and tags (string-match-p (regexp-quote ":ignore:") tags))
               ;; Otherwise, we want to check this heading's custom ID.
               (let ((id (org-entry-get nil "CUSTOM_ID")))
                 ;; If `id` was not found, or if it seems to have been generated by this function,
                 ;; proceed to generate a new custom ID.
                 (unless (and id (not (string-prefix-p prefix id)))
                   ;; Create the id. Concatenate the prefix...
                   (let ((new-id (concat prefix
                                     ;; ...with this heading's headline
                                     ;; (note spaces are not allowed in links;
                                     ;; substitute dashes for any found.)
                                     (s-replace " " "-" headline))))
                          (push new-id generated-ids)
                     ;; Finally, add a counter of the number of
                     ;; previous occurrences of this id, to prevent repetition.
                     (let ((unique-id (append-counter
                                        new-id 
                                        (seq-count (lambda (x) (string-equal x new-id))
                                                   generated-ids))))
                       (org-entry-put nil "CUSTOM_ID" unique-id)))))))))))))

;; Whenever html & md export happens, ensure we have headline ids.
(advice-add 'org-html-export-to-html :before 'my/ensure-headline-ids)
(advice-add 'org-md-export-to-markdown :before 'my/ensure-headline-ids)
#+end_src

*** Additional export formats

**** Org Reveal

I make use of ~org-reveal~ to create ~reveal.js~ slide decks.
This is way easier than dealing with ~beamer~ in LaTeX,
and results in much more attractive and better organised slides.
#+Name: export-reveal
#+begin_src emacs-lisp
(use-package ox-reveal)
#+end_src

If we're somewhat lazy, we to could keep
a local copy of the ~reveal.js~ packages,
and then point to it with the ~org-reveal-root~ variable.
More proactively, we can include the repo as a subrepo
of whatever project we're working on.
:TODO: Add instructions on how to do that here.

***** Theme

~reveal.js~ comes with many themes; ~black~ is the current default
at time of writing this. I set it just to be sure it stays consistent.

#+Name: export-reveal-theme
#+begin_src emacs-lisp
(setq org-reveal-theme "black")
#+end_src

At the time of writing, the included themes are
- ~black~: Black background, white text, blue links
- ~white~: White background, black text, blue links
- ~league~: Gray background, white text, blue links
- ~beige~: Beige background, dark text, brown links
- ~sky~: Blue background, thin dark text, blue links
- ~night~: Black background, thick white text, orange links
- ~serif~: Cappuccino background, gray text, brown links
- ~simple~: White background, black text, blue links
- ~solarized~: Cream-colored background, dark green text, blue links
(list from the [[https://github.com/hakimel/reveal.js/#theming][~reveal.js~ github]]).

***** Title page

The default title slide includes title and date, with the formatting
#+begin_src html
<h1 class="title">%t</h1>
<p class="date">Created: %d/p>
#+end_src
where ~%t~ stands for the document title and ~%d~ stands for the date.

I prefer a slightly smaller title, and additionally include
- the author name (~%s~) and
- the author email (~%a~).
#+Name: export-reveal-title
#+begin_src emacs-lisp
(setq org-reveal-title-slide
  "<h2 class=\"title\">%t</h2>
   <h3>%s</h3>
   <h4>%a</h4>
   <h5>%d</h5>")
#+end_src

**** Pandoc export formats

~ox-pandoc~ is “another exporter that translates Org-mode file to various other
formats via Pandoc”.

I don't make much use of it, but it more flexible, and so has
lots of options which make be useful in the future.

#+Name: export-pandoc
#+begin_src emacs-lisp
(use-package ox-pandoc)
#+end_src

*** Export markdown blocks as HTML

If we are given some markdown we wish to place into an Org file,
we can of course convert it to Org and place it appropriately.

If we're only interested in exporting to HTML, though,
we can more easily just put the markdown into a ~markdown~ ~src~ block,
and it can automatically be evaluated into HTML.

Note the result will not be visible in PDF exports!

For the basic process,
see https://christiantietze.de/posts/2020/10/org-babel-markdown-to-html/

First, we need Org babel functions for markdown;
apparently, this ten-year old (at time of writing) code
—https://github.com/tnoda/ob-markdown/blob/master/ob-markdown.el—
that does not seem to be in a package repository is
the best candidate.
#+begin_src emacs-lisp
(use-package markdown-mode)
(require 'ob-markdown)
#+end_src

Now we instruct Org mode to, by default,
wrap the results of evaluating ~markdown~ blocks in ~example html~ blocks,
and then export those results.
Again, note that nothing will show up in LaTeX exports!
#+begin_src emacs-lisp
(add-to-list 'org-babel-default-header-args:markdown
             '(:results . "output verbatim html"))
(add-to-list 'org-babel-default-header-args:markdown
             '(:exports . "results"))
#+end_src

*** Letters

When writing a letter, I use
[[https://www.ctan.org/pkg/scrlttr2][the Koma-Script letter class]]
for LaTeX, rather than the default letter class.
There is a nice package giving support for using Org mode
to organise the letter.
#+begin_src emacs-lisp
(require 'ox-koma-letter)
#+end_src

Here's a sample Org document to produce a simple letter.
I have it set to tangle to [[/tmp/letter-template.org]],
so I can quickly copy it when I want to write a letter.
#+begin_src org :tangle /tmp/letter-template.org
#+Title: A title for the produced PDF, not shown on the page unless set to do so
#+Author: Mark Armstrong
#+Date: The date

,* My contact info                               :noexport:

#+Email: markparmstrong@gmail.com
#+Phone_number: 111-111-1111
#+URL: armkeh.github.io

,* Preamble                                      :noexport:

#+Subject: Computer programming part-time/summer camp instructor position

Disregard the title. Use only subject, and center it.
#+Options: title:nil subject:centered

Include my email, phone and URL in my address.
Make sure to set these above!
#+Options: email:t phone:t url:t

Don't print the foldmarks.
#+Options: foldmarks:nil

#+LCO: UScommercial9

,* To                                            :to:

Their mailing address

,* From                                          :from:

My mailing address

,* Dear recipient,

Here is my awesome letter.

,* All the best,                                 :closing:

Mark Armstrong
#+end_src

** A completion framework; Ivy, Counsel and Swiper :completion:

:TODO: Better documentation here.

*** Ivy

#+begin_src emacs-lisp
(use-package ivy
  :config
  (ivy-mode 1)
#+end_src

Add recent files and bookmarks to ~ivy-switch-buffer~.
#+begin_src emacs-lisp
  (setq ivy-use-virtual-buffers t)
#+end_src

Display both the index and the count in the current candidate count.
#+begin_src emacs-lisp
  (setq ivy-count-format "(%d/%d) ")
#+end_src

Enable minibuffer commands in the minibuffer.
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src

# End the settings
#+begin_src emacs-lisp
)
#+end_src

*** Swiper

#+begin_src emacs-lisp
(use-package swiper
  :config
  ;; (global-set-key "\C-r" 'swiper)
  (global-set-key (kbd "C-s") 'swiper))
#+end_src

*** Counsel

:TODO: Move keybindings to General settings.
#+begin_src emacs-lisp
(use-package counsel
 :config
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file))
#+end_src

*** Prescient

#+begin_quote
~prescient.el~ is a library which sorts and filters lists of candidates,
such as appear when you use a package like Ivy or Company.
Extension packages such as ~ivy-prescient.el~ and ~company-prescient.el~ adapt
the library for usage with various frameworks.
#+end_quote

In particular, I like to have recently run invoked commands appear
as the first suggestions when I use ~M-x~.
#+begin_src emacs-lisp
(use-package prescient)
(use-package ivy-prescient)
(ivy-prescient-mode)
#+end_src

** COMMENT Improving search; CTRLF (control f)

https://github.com/raxod502/ctrlf

Can I get over ~C-s~ not jumping to the minibuffer
if a search is already running?
If not, bring swiper back.
#+begin_src emacs-lisp
(use-package ctrlf)
(ctrlf-mode +1)
#+end_src

** COMMENT A completion framework; Selectrum

https://github.com/raxod502/selectrum

#+begin_src emacs-lisp
(use-package selectrum)
(selectrum-mode +1)
#+end_src

** COMpleting ANYthing; Company                :completion:

:TODO: Review these settings, and consider reformatting to avoid open parenthese across codeblocks.

Install ~company~ and set it to be used everywhere.
#+begin_src emacs-lisp
(use-package company
  :diminish
  :config
  (global-company-mode 1)
  (setq
#+end_src

I do find it convenient to require few characters before
getting autocomplete suggestions, but on my Chromebook
that slows things down far too much.
Let's require 4 characters before suggestions are provided.
#+begin_src emacs-lisp
   company-minimum-prefix-length 4
#+end_src

Search buffers using the same major mode for completion candidates.
Setting ~all~ instead would search all buffers.
#+begin_src emacs-lisp
   company-dabbrev-other-buffers t
   company-dabbrev-code-other-buffers t
#+end_src

Sort candidates by importance, then case, then in-buffer frequency.
#+begin_src emacs-lisp
   company-transformers '(company-sort-by-backend-importance
                          company-sort-prefer-same-case-prefix
                          company-sort-by-occurrence)
#+end_src

Align any annotations to completions to the right.
#+begin_src emacs-lisp
   company-tooltip-align-annotations t
#+end_src

Annotate the completions with numbers.
We can select an annotation with ~M-num~ instead
of navigating to it.
#+begin_src emacs-lisp
   company-show-numbers t
#+end_src

Show up to ten candidates in a tooltip.
When we get to the bottom of the list, wrap.
#+begin_src emacs-lisp
   company-tooltip-limit 10

   company-selection-wrap-around t
#+end_src

Don't downcase by default,
but if I choose a completion with different casing
than my prefix, change the prefix casing.
#+begin_src emacs-lisp
   company-dabbrev-downcase nil
   company-dabbrev-ignore-case nil
#+end_src

Pause very briefly before offering completion.
This way if I am typing quickly it does not try to interrupt.
#+begin_src emacs-lisp
   company-idle-delay 0.2)
#+end_src

Rebind the controls for completion.
I find using ~return~ distruptive, as often I mean to insert a newline
instead of complete a suggestion.
Use ~tab~ instead.
Also, if documentation is available, ~C-d~ accesses it
in a new temporary buffer.
#+begin_src emacs-lisp
  :bind (:map company-active-map
              ;; Don't complete on return.
              ("<return>" . nil) ("RET" . nil)
              ;; Use tab instead.
              ("<tab>" . company-complete-selection)
              ("C-d" . company-show-doc-buffer))) 
#+end_src

Pop up a tooltip when I hover on a completion that has documentation.
#+begin_src emacs-lisp
(use-package company-quickhelp
 :config
   (setq company-quickhelp-delay 0.1)
   (company-quickhelp-mode))
#+end_src

Add emoji support. For instance, ~:smile:~ completes to 😄.
#+begin_src emacs-lisp
(use-package company-emoji
  :config (add-to-list 'company-backends 'company-emoji))
#+end_src

** Snippets                                    :completion:

I use ~yasnippets~ for text expansion, and ~yankpad~ to organise my
snippets.

For inserting snippets, we require string manipulation functions
from the ~subr-x~ package (built-in).
#+begin_src emacs-lisp
(require 'subr-x)
#+end_src

#+begin_src emacs-lisp
(use-package yasnippet)
(yas-global-mode t)

(use-package yankpad)
(setq yankpad-file "~/dotfiles/emacs/yankpad.org")
#+end_src

Ignore major mode, always use defaults.
Yankpad will freeze if no org heading has the name of the given category.
#+begin_src emacs-lisp
(setq yankpad-category "Default")
#+end_src

~yas-wrap-around-region~ controls what is inserted for a snippet's
~$0~ field. A non-nil, non-character setting has it insert the
current region's contents (i.e. if we highlight a region and
invoke a snippet, the region will be wrapped).
#+begin_src emacs-lisp
(setq yas-wrap-around-region t)
#+end_src

~yas-indent-line~ controls how inserted snippets are inserted.
~fixed~ indicates the snippet should be indented to the column at point.
~auto~ instead causes each line to be indented using ~indent-according-to-mode~.
I set it to fixed because this is usually what I want; I know best, not the mode.
#+begin_src emacs-lisp
(setq yas-indent-line 'fixed)
#+end_src

*** Interacting with Company

Taken without additional commentary for now from Musa's init.
#+begin_src emacs-lisp
;; Add yasnippet support for all company backends
;;
(cl-defun my/company-backend-with-yankpad (backend)
  "There can only be one main completition backend, so let's
   enable yasnippet/yankpad as a secondary for all completion
   backends.

   Src: https://emacs.stackexchange.com/a/10520/10352"

  (if (and (listp backend) (member 'company-yankpad backend))
      backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yankpad))))

;; Set company-backend as a secondary completion backend to all existing backends.
(setq company-backends (mapcar #'my/company-backend-with-yankpad company-backends))
#+end_src

** Walking through undo history; undo-propose  :vc:

The ~undo-propose~ package is a fairly minimal addition to
the builtin undo features of Emacs
(which can be confusing, but are very powerful,
 since undo-ing is an action which can be undone.)
#+begin_src emacs-lisp
(use-package undo-propose)
#+end_src

What ~undo-propose~ does is open a new, read-only buffer
in which the undoing is to be done
(~undo~ and ~undo-only~ are wrapped so as to be allowed,
 although the buffer is read-only.)
It provides commands to
- overwrite the original buffer,
  - either as a single (squashed) action (~C-c C-s~),
  - or as the chain of undo actions performed (~C-c C-c~),
- run a diff against the original buffer (~C-c C-d~), or
- be discarded entirely (~C-c C-k~.)

Notice that undo history can be viewed as
a very crude local version control.
Local in two senses;
- in space, because the history is only available on our current machine, and
- in time, because the history is lost when the buffer is closed
  (or Emacs closes.)
Still, this history can be of use, and when combined with automatic backups
(see [[Organising automatic backups]] and [[Walking through backups; backup-walker]]),
and usually further an actual version control system such as Git,
we can be reasonably assured we will not find ourselves
wanting to recover some deleted work and being unable to.

*** What about undo-tree?

In the past, I have used ~undo-tree~ to visualise
the changes to a file as a tree,
allowing movement up and down branches as a local sort
of version control.
But the actual visualisation can sometimes cause lag,
and ~undo-tree~ has been known to cause corruptions
when undoing/redoing (though I have not experienced this personally.)
For the moment, I will stick to the builtin undo behaviour,
with ~undo-propose~ to help visualise the changes.

** Walking through backups; backup-walker

The ~backup-walker~ package gives us the resources
to actually make use of the backups Emacs generates as
a crude offline version control.
It enables us to traverse backwards and forwards in time
through the backups, seeing a diff at each step.
Try it out with ~backup-walker-start~,
and move back and forth with ~n~ and ~p~.
#+begin_src emacs-lisp
(use-package backup-walker)
#+end_src

** Jumping through the buffer by characters    :movement:

A bit of common wisdom to avoid RSI (repetivie strain injuries)
says to avoid moving between keyboard and mouse frequently;
leave your hands in a (properly relaxed and comfortable)
keyboard position as much as possible.
With this in mind, we should have ways to move the cursor
that don't involve the mouse, but also don't involve
mashing the arrow keys or similar.

[[https://github.com/abo-abo/avy][~avy~]] is a
“package for jumping to visible text using a char-based decision tree”.
We invoke a command, type one, two or a small handful of characters,
and then can use homerow keys to decide which instance of those characters
on-screen to jump to.
We can even jump to other windows!
#+begin_src emacs-lisp
(use-package avy)
#+end_src

** Viewing files (and contents) using a tree layout :movement:

A common feature for modern text editors and IDEs
is a narrow left window (or in other terminology, frame),
showing the layout of the local directories and files as a tree,
allowing for quick opening of other files in the current project.

Of course, Emacs has packages that provide this;
[[https://github.com/Alexander-Miller/treemacs][Treemacs]] is one such.
#+begin_src emacs-lisp
(use-package treemacs)
#+end_src

If I am keeping the Treemacs window open, I want it to not take
too much space. As we move the cursor through the list,
the full filepath of items is expanded in the echo area ansyway.
#+begin_src emacs-lisp
(setq treemacs-width 20)
#+end_src

Since the window is narrow, don't indent much.
#+begin_src emacs-lisp
(setq treemacs-indentation 1)
#+end_src

Icons are a nice visual tool to help ease visual identification
of files which may have similar names but different types,
but I find the default size is too large, taking up precious space.
The default size is 22. 44 is recommended for high-DPI screens,
but I use 11 to reserve space.
#+begin_src emacs-lisp
(treemacs-resize-icons 11)
#+end_src

* Final cosmetics

** Icon support

The ~all-the-icons~ package provides icons to prettify things
or replace certain text.
#+begin_src emacs-lisp
(require 'all-the-icons)
#+end_src

The ~all-the-icons-dired~ package adds icons
corresponding to file types next to files in the list.
#+begin_src emacs-lisp
(require 'all-the-icons-dired)
(add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+end_src

** Modeline styling                            :theme:

*** Add styling via Doom modeline

I previously used Spaceline, the Spacemacs modeline,
which is a very nice appearing modeline replacement.
Now prefer Doom modeline, which is a fair bit more “plain”,
but still very nice in appearance,
and is compatible with far more modeline additions
(in particular, the modeline scroll bar I like;
 see [[Add a little scrollbar to the modeline]].)
#+begin_src emacs-lisp
(use-package doom-modeline)
#+end_src

Do display an icon indicating if the file in the buffer
has changed from the disk.
Note that even without this,
the filepath will change colours when the file has been modified.
#+begin_src emacs-lisp
(setq doom-modeline-buffer-state-icon t)
#+end_src

I find the Doom modeline takes a little too much
vertical space by default; it will always take
at least as much vertical space as needed for its contents,
so set its height to ~0~ to make it as short as possible.
#+begin_src emacs-lisp
(setq doom-modeline-height 0)
#+end_src

*** Set up the items on the Doom-modeline

I like to strip down the amount of information on the modeline
to what I might actually make use of.
The Doom modeline provides ~doom-modeline-set-modeline~ 
#+begin_src emacs-lisp
(doom-modeline-def-modeline 'my/doom-modeline
  ;; Left side
  '(window-number remote-host buffer-info buffer-encoding buffer-position)
  ;; Right side
  '(major-mode minor-modes input-method process))

(defun my/doom-modeline-setter ()
   (doom-modeline-set-modeline 'my/doom-modeline 'default))
(add-hook 'doom-modeline-mode-hook 'my/doom-modeline-setter)
#+end_src
Note that some information, such as the current time and my unread email count,
I display in the ~global-mode-string~ which I include in my tab bar instead of here.

The minor mode listing is disabled by default.
This also disables the ~minion~ button if using that
(which provides a pop-up menu which lists and allows toggling
 of minor modes.)
#+begin_src emacs-lisp
(setq doom-modeline-minor-modes t)
#+end_src

*** Activate the Doom modeline

Once everything is set, actually activate the new modeline.
#+begin_src emacs-lisp
(doom-modeline-mode 1)
#+end_src

** Flash on error

The doom themes package comes with a function to make
the mode line flash on error.
#+begin_src emacs-lisp
(use-package doom-themes)
(require 'doom-themes-ext-visual-bell)
(doom-themes-visual-bell-config)
#+end_src
I'd previously just used ~visible-bell~, but it's a bit nosier
than necessary.

** Add a little scrollbar to the modeline

While I disable the usual scrollbars to save space,
they can be useful for giving a visualisation
of where we are in the buffer.
There are a few ways to add such a visual representation
to the modeline instead; the ~mlscroll~ package
is one, and the small horizontal scrollbar it
can actually be used as a scrollbar. Neat!
#+begin_src emacs-lisp
(use-package mlscroll)
(setq mlscroll-right-align nil)
(setq mlscroll-alter-percent-position 'replace)
(mlscroll-mode 1)
#+end_src

** Show the clock

Let's display the current time, with updates every minute.

First set the format for the clock.
- ~%a~ for abbreviated day of the week name.
- ~%b~ for abbreviated month name.
- ~%d~ for day of the month.
- ~%R~ for hour and minute, separated by a ~:~, in 24-hour format.
#+begin_src emacs-lisp
(setq display-time-format "%a %b %d %R")
#+end_src

Do not show load and mail in the time string; I include that information separately.
#+begin_src emacs-lisp
(setq display-time-default-load-average nil)
(setq display-time-mail-file nil) ;; This is default, but I set it as documentation for myself.
#+end_src

Now activate the mode.
#+begin_src emacs-lisp
(display-time-mode 1)
#+end_src

I've found when using ~doom-modeline~ (and hence possibly other custom modelines),
the ~global-mode-string~ gets modified on me to not include the time string;
let's ensure it's added in.
Note that this section must then go after custom modeline setup.
#+begin_src emacs-lisp
(add-to-list 'global-mode-string 'display-time-string 'append)
#+end_src

** Kill the open init buffer and reopen it     :cleanup:

To ensure all these cosmetic changes are picked up,
kill my init buffer that we opened earlier and reopen it.
#+begin_src emacs-lisp
(kill-buffer "emacs-init.org")
(find-file my/emacs-init-file)
#+end_src

* Final (nearly) modes and final mode-specific settings

** Org mode                                    :org:

*** Speed keys

Speed keys are single keystrokes which execute commands in an
~org~ file when the cursor is at the start of a headline.
They are particularly useful for quickly moving a headline around,
or promoting/demoting a headline (and all children headlines accordingly.)
#+begin_src emacs-lisp
(setq org-use-speed-commands t)
#+end_src

To see the commands available, execute
#+begin_example emacs-lisp
(org-speed-command-help)
#+end_example

*** Automatic tables of contents

This package provides automatic maintainance of a table of contents
under any heading which is labelled with the ~:TOC:~ tag.
#+begin_src emacs-lisp
(use-package toc-org
  ;; Automatically update toc when saving an Org file.
  :hook (org-mode . toc-org-mode))
#+end_src

*** Custom TODO keywords

These words, when appearing at the start of a headline,
mark that headline as a TODO task in the appropriate state.
I've added =SOON=, =NEXT=, =WORKING=, =DELEGATED= and =CANCELLED=.
#+begin_src emacs-lisp
(setq org-todo-keywords
  '((sequence "TODO" "DELEGATED" "SOON" "NEXT" "WORKING" "OVERDUE" "|" "DONE" "CANCELLED")))
#+end_src

Note the ~"|"~ entry; headlines marked with any of the states
past that entry are considered to be completed.
Those before the ~"|"~ are still outstanding tasks.

*** Clock closing time for TODO items

Record the time a TODO task entered a completed state
in a ~CLOSED~ field under the heading.
This is entered automatically when using Org to switch between TODO states.
Using ~org-speedkeys~, you can cycle states
by using ~t~ on the leftmost asterisk of a heading.
#+begin_src emacs-lisp
(setq org-log-done 'time)
#+end_src

*** Allow alphabetical lists

While not frequently that useful, it is nice to be allowed
to label list items alphabetically.
Note that the labels used in the plaintext Org do not affect the labels
used in most export formats (at least HTML and LaTeX.)
#+begin_src emacs-lisp
(setq org-list-allow-alphabetical t)
#+end_src

*** Agenda

#+begin_src emacs-lisp
(setq org-agenda-files
  '("~/logs/personal/todo.org"))
#+end_src

** Alerts for emails                           :mail:

The ~mu4e-alert~ package provides the ability to get
various kinds of alert about incoming mail using ~mu4e~.
#+begin_src emacs-lisp
(use-package mu4e-alert)
#+end_src

Use the Emacs ~notifications~ libraries to send
desktop notifications (OS-level notifications.)
This should work on Linux systems.
We can set ~lib-notify~ instead (for Linux),
but this way we don't rely on that library being installed.
But in my current workflow, desktop notifications
are in fact an unnecessary distraction;
I already receive notifications in Emacs, on my phone
and on my watch. So this is commented out for now.
#+begin_src emacs-lisp
;;(mu4e-alert-set-default-style 'notifications)
;;(add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
#+end_src

Show the unread email count (or however we format the alert)
in the global information area, which usually shows on the modeline.
I actually show that on the tab-bar instead.
#+begin_src emacs-lisp
(mu4e-alert-enable-mode-line-display)
#+end_src

Only alert for emails coming into the inbox.
Don't worry about other mail directories.
(I direct some less urgent mail to other directories,
 and don't want to be bothered by notifications from them.)
Do include all mail in the inbox, even if it is read;
I follow a “zero inbox” approach, so the number of emails
in the inbox is the number of emails I still have to deal with today,
even if some or all are marked as read.
#+begin_src emacs-lisp
(setq mu4e-alert-interesting-mail-query
   (concat
      ;;"flag:unread"
      "maildir:/Inbox"))
#+end_src

Only show the count of unread emails in the notifications,
not the senders or subjects.
:TODO: Does this stop the message spam?
#+begin_src emacs-lisp
(setq mu4e-alert-email-notification-types '(count))
#+end_src

** Dired

~dired~ (for DIRectory EDitor) is Emacs builtin utility
for browsing directories and operating on their contents.

Herein are my (fairly minimal) modifications to its behaviour.

*** File information

~dired~ makes use of switches for ~ls~.
#+begin_src emacs-lisp
(setq dired-listing-switches
      "--group-directories-first -aDgGhL --time-style \"+  %Y %b %d %H:%M  \"")
#+end_src

Here's a description of those single letter switches.
| ~-a~                        | do not ignore entries starting with .                      |
| ~-g~                        | long listing format, but do not list owner                 |
| ~-G~                        | in a long listing, don't print group names                 |
| ~-h~                        | print human readable size                                  |
| ~-L~                        | show information for /references/ rather than symbolic links |

In the past, I had also used ~-B~ to ignore entries
ending with ~~~, in order to ignore automatic Emacs backup files.
I now organise those files into a set directory,
so I do want to see them if they are somehow present.

*** Cosmetic

Don't display whitespace information via ~whitespace-mode~ in Dired buffers.
#+begin_src emacs-lisp
(add-hook 'dired-mode-hook
  (lambda ()
     (setq-local whitespace-style nil)))
#+end_src

Highlighting the whole line we're on helps keep track of what file
the cursor is on.
#+begin_src emacs-lisp
(add-hook 'dired-after-readin-hook 'hl-line-mode)
#+end_src

** Eshell                                      :programming:

The Eshell is a wonderful shell-like command interpreter inside of Emacs.
I find it's not appropriate for intensive command line tasks,
but it's nice not to have to leave Emacs for simple tasks.
(Note there are alternatives for this purpose, including
 popping up an external shell inside of Emacs.)
#+begin_src emacs-lisp
(use-package eshell)
#+end_src

Jeremias Queiroz posted a “fancy eshell prompt” setup on [[https://www.reddit.com/r/emacs/comments/6f0rkz/my_fancy_eshell_prompt/][Reddit]],
from which I derived this setup, but I've modified it to use
builtin face colours to improve portability across themes.
For instance, the ~default~ colour will most likely be white
for dark themes and black for light themes.
#+begin_src emacs-lisp
(setq eshell-prompt-function
  (lambda ()
    (let ((default  (face-attribute 'default :foreground))
          (green    (face-attribute 'success :foreground))
          (red      (face-attribute 'error   :foreground))
          (blue     (face-attribute 'link    :foreground))
          (yellow   (face-attribute 'warning :foreground)))
    (concat
    (propertize "┌—["                 'face  `(:foreground ,green))
    (propertize (user-login-name)     'face  `(:foreground ,red))
    (propertize "@"                   'face  `(:foreground ,blue))
    (propertize (system-name)         'face  `(:foreground ,red))
    (propertize "]──["                'face  `(:foreground ,green))
    (propertize (format-time-string "%a %b %d" (current-time)) 'face `(:foreground ,yellow))
    (propertize "]──["                'face `(:foreground ,green))
    (propertize (format-time-string "%H:%M" (current-time)) 'face `(:foreground ,yellow))
    (propertize "]\n"                 'face `(:foreground ,green))
    (propertize "│ "                  'face `(:foreground ,green))
    (propertize (concat (eshell/pwd)) 'face `(:foreground ,blue))
    (propertize "\n"                  'face `(:foreground ,green))
    (propertize "└─►"                 'face `(:foreground ,green))
    (propertize (if (= (user-uid) 0) " # " " $ ") 'face `(:foreground ,default))))))
#+end_src

** Which key                                   :completion:

~which-key-mode~ is a handy minor mode that shows us
possible completions as we type commands.
Very useful if you remember only a prefix of the command,
not the whole thing.
#+begin_src emacs-lisp
(use-package which-key)
(which-key-mode)
#+end_src

It is also useful for discovery of shortcuts;
occasionally it is enlightening to take some time
and browse the possible completions of prefixes as you type.

** Winner mode                                 :window:

~winner-mode~ allows us to undo or redo changes to window layouts.
See my keybindings for this above.
#+begin_src emacs-lisp
(winner-mode 1)
#+end_src

** Easier movement between windows – Windmove  :window:

The package ~windmove~ lets us jump between windows in a frame.
#+begin_src emacs-lisp
(use-package windmove)
#+end_src

(For the uninitiated, a /window/ in Emacs is not the same as
 the OS window. Each OS window is a /frame/, and each pane within
 a frame is called a /window/. Emacs predates modern terminology.)

~windmove~ lets us move between windows with the arrow keys
while holding a key; by default, the key is ~shift~.
That conflicts with ~org~ though, so we could use
~windmove-default-keybindings~ to change it.

** Window numbers – Winum                      :window:

While ~windmove~ is wonderful, if we have several windows
in the frame, it can be tedious to move between them,
since it may required several commands in a row.
In the case, perhaps we prefer to jump straight to windows,
by assigning each window a number and jumping based on those numbers.
The ~winum~ package facilitates this.
#+begin_src emacs-lisp
(use-package winum)
(winum-mode)
#+end_src

** Ediff                                       :vc:

By default, when using the GUI, Ediff opens a new frame for
the controls for the Ediff session.
I typically use Emacs in fullscreen, and this additional frame
is usually unwelcome. Instead, use a window in the current frame.
#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

I prefer to see the files being compared side by side,
rather than split vertically.
#+begin_src emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally)
#+end_src

** Magit                                       :vc:

Explicitely install Magit; “a Git Porcelain inside Emacs”.
This is a killer feature of Emacs; Magit not only simplifies
interation with Git, it also expands our capabilities
in many ways over the CLI.
:TODO: Explain some here or link to some examples?
#+begin_src emacs-lisp
(use-package magit)
#+end_src

“Forge allows you to work with Git forges, such as Github and Gitlab,
from the comfort of Magit and the rest of Emacs.”
I do not yet use this extensively, but mean to at some point,
in order to keep more of my work tasks in Emacs 😄.
#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src

*** Commit messages

Commit message subjects should be short and sweet.
Many sources suggest a soft limit of just 50 characters,
with 72 being a hard upper limit; this is even pseudo-enforced
on Github (at least), with characters after 72 being hidden by default.
(See [[https://cbea.ms/git-commit/][this post]] on well-written commit messages.)

To this end, Magit tries to enforce a line length of 72,
(actually 68, to avoid long words trailing off the end)
by forcefully breaking the line for you when you enter a space
if it is too long.

Unfortunately, this advice can conflict with other requirements
in the workplace; in particular
with [[https://www.conventionalcommits.org/en/][conventional commits]]
and adding ticket numbers to commit messages.

To avoid having to fight with Magit to un-break the line
in the case that I go over 72 characters,
I increase the allowance by a bit.
Let's go with 1.5 times the length.
#+begin_src emacs-lisp
(setq git-commit-summary-max-length 98)
#+end_src

** Show uncommitted changes to files as we view them :vc:

~magit~ is awesome; aside from the fine-grained control
over what to add from a file, its status buffer
gives a really nice way to review the changes to files
using Org-mode like folding.

But just a useful, or perhaps moreso, for reviewing changes to files
are the packages ~diff-hl~ and ~git-gutter~, which show
the status of lines by marking the gutter area
to show added and modified lines.
#+begin_src emacs-lisp
(use-package git-gutter)
(global-git-gutter-mode)
#+end_src

And it provides controls to jump between and act on those changes,
so for simple commits we may not even need the ~magit~ status buffer.
:TODO: Shortcuts to jump between and act on hunks. Probably a hydra! See Musa's setup.

** Minions; see and toggle minor modes         :simplify:

The ~minions~ package implements a handy pop-up menu
for toggling minor modes.
While I don't really care for a GUI menu for toggling,
it is a convenient way to view the minor modes that are active
(along with commonly used ones that are inactive),
without taking extra space on the modeline
or opening a help buffer.
#+begin_src emacs-lisp
(use-package minions)
(minions-mode 1)
#+end_src

* Programming language modes and mode-specific settings

** Language server protocol                    :programming:

#+begin_src emacs-lisp
(use-package lsp-mode)
#+end_src

Add integrations with some other packages.
#+begin_src emacs-lisp
(use-package lsp-ivy)
(use-package lsp-treemacs)
#+end_src

** JSON                                        :programming:

#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

** Dhall configuration language                :programming:

#+begin_src emacs-lisp
(use-package dhall-mode)
#+end_src

** Purescript                                  :programming:

#+begin_src emacs-lisp
(use-package purescript-mode)
#+end_src

** Elm                                         :programming:

#+begin_src emacs-lisp
(use-package elm-mode)
#+end_src

** Go (sometimes called Golang)                :programming:

Activate Org babel support for Go.
:TODO: Commentary on how to evaluate Go code nicely.
#+begin_src emacs-lisp
(use-package ob-go)
#+end_src

#+begin_src emacs-lisp
(use-package go-mode)
;(use-package go-lint)
#+end_src

#+begin_src emacs-lisp
(add-hook 'go-mode-hook 'lsp-deferred)
#+end_src

Activate ~gofmt~ upon save.
#+begin_src emacs-lisp
(add-hook 'go-mode-hook
          (lambda () (add-hook 'before-save-hook gofmt-before-save nil 'local)))
#+end_src

** YAML configuration language                 :programming:

:TODO: Commentary needed.
#+begin_src emacs-lisp
(use-package yaml-mode)
#+end_src

:TODO: Probably some better settings could be filled in, since I actually use this at work.

** TOML configuration language                 :programming:

:TODO: Commentary needed.
#+begin_src emacs-lisp
(use-package toml-mode)
#+end_src

** Common Lisp                                 :programming:

Org babel support for Lisp is builtin, so just ~require~ it.
#+begin_src emacs-lisp
(require 'ob-lisp)
#+end_src

:TODO: Commentary needed.
#+begin_src emacs-lisp
(use-package slime)
#+end_src

#+begin_src emacs-lisp
(setq slime-contribs                 '(slime-fancy)
      slime-complete-symbol-function 'slime-fuzzy-complete-symbol
      slime-net-coding-system        'utf-8-unix
      slime-lisp-implementations     '((sbcl  ("sbcl"))
                                       (abcl  ("abcl"))
                                       (clisp ("clisp"))))
#+end_src

Fill in the paths if necessary.
#+begin_src text
~/.guix-profile/bin/
~/.guix-profile/bin/
~/.guix-profile/bin/
#+end_src

** Geiser Emacs/Scheme                         :programming:

Org babel support for scheme is builtin, so just ~require~ it.
#+begin_src emacs-lisp
(require 'ob-scheme)
#+end_src

:TODO: Commentary needed.
#+begin_src emacs-lisp
(use-package geiser)
#+end_src

** Geiser Guile scheme support                 :programming:

:TODO: Commentary needed.
#+begin_src emacs-lisp
(use-package geiser-guile)
#+end_src

** Clojure                                     :programming:

Org babel support for clojure is builtin, so just ~require~ it.
#+begin_src emacs-lisp
(require 'ob-clojure)
#+end_src

:TODO: Commentary needed.
#+begin_src emacs-lisp
(setq org-babel-clojure-backend 'cider)
(use-package cider)
(setq cider-default-repl-command "lein")
#+end_src

** Ammonite (deprecated)                       :programming:

~ob-ammonite~ interacts with the ~ammonite~ REPL for ~scala~.
Unfortunately it's been dropped off MELPA, apparently.
It should still be available on [[https://github.com/zwild/ob-ammonite][Github]].
If I ever come back to this, maybe I should fork the project,
or rebuild my own; it's not that large.
#+begin_src emacs-lisp
;; (use-package ob-ammonite)
#+end_src
Note that the ~scala~ source blocks are marked as ~amm~ source,
not actually ~scala~. See
[[https://github.com/zwild/ob-ammonite][the documentation]].

This code causes Ammonite ~amm~ blocks to export as ~scala~ blocks
in LaTeX so ~minted~ knows how to handle them.
This code inspired by a similar problem solved on
[[https://emacs.stackexchange.com/a/19941][StackExchange]].
#+begin_src emacs-lisp
(defun my/ammonite-src-to-scala-src (text backend info)
  "Translate Ammonite minted blocks resulting from LaTeX export
to Scala minted blocks."
  (when (org-export-derived-backend-p backend 'latex)
    (with-temp-buffer
      (insert text)
      (goto-char (point-min))
      (replace-regexp "\\(\\\\begin{minted}.*\\){amm}" "\\1{scala}")
      (buffer-substring-no-properties (point-min) (point-max)))))

(add-hook 'org-export-filter-src-block-functions 'my/ammonite-src-to-scala-src)
#+end_src

** Ditaa                                       :programming:

Ditaa is a neat little tool for producing images from ASCII diagrams.
It's great for simple diagrams in Org mode presentations,
as the source code can be embedded in the Org but hidden in the produced document,
replaced by the generated image.

Org babel support for Ditaa is builtin, so just ~require~ it.
#+begin_src emacs-lisp
(require 'ob-ditaa)
#+end_src

We need to point to the ~jar~ file for the Ditaa tool.
#+Name: evaluate-ditaa-path
#+begin_src emacs-lisp
(setq org-ditaa-jar-path "/usr/bin/ditaa")
#+end_src

* Session setup

Before anything, we opened my init file earlier;
kill that buffer now, so that it's not open if it's not wanted,
or if it is wanted, so that cosmetic changes we made above
will be properly applied.
#+begin_src emacs-lisp
(kill-buffer "emacs-init.org")
#+end_src

Also go ahead and close any windows that may have been created.
#+begin_src emacs-lisp
(delete-other-windows)
#+end_src

The remainder of these settings are segragated,
and then loaded based on the identity of the machine being used.

** Personal machines
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/dotfiles/emacs/personal-session.el
:END:

*** Filepaths

For maintainability, most files opened below
are listed here.
#+begin_src emacs-lisp
(setq-local my/log-dir   "~/logs/")
(setq-local my/scratch-dir "~/logs/scratch/")
(setq-local my/dotfiles-dir "~/dotfiles/")
(setq-local my/emacs-dir (concat my/dotfiles-dir "emacs/"))
(setq-local my/agda-dir  "~/Dropbox/McMaster/Agda/")

(setq-local my/emacs-init   (concat my/emacs-dir "emacs-init.org"))
(setq-local my/yankpad-file (concat my/emacs-dir "yankpad.org"))

(setq-local my/journal (concat my/log-dir "personal/journal.org"))

(setq-local my/org-scratch  (concat my/scratch-dir "org-scratch.org"))
(setq-local my/agda-scratch (concat my/agda-dir "agda-scratch.agda"))
#+end_src

*** Create tabs

First, let's create some “consistent” tabs;
whatever projects I am working on, these tabs
will always be present.
- First, of course, is my Emacs init.
- Second, my Emacs init again, alongside a ~magit~ buffer for it.
- Second, my Org log and my email.
- Third, an ~eshell~ instance (separate from the one
  invoked by my ~eshell~ shortcut).
#+begin_src emacs-lisp
(tab-rename "init")
(tab-new)
(tab-rename "dotfiles ꇚ")
(tab-new)
(tab-rename "Logs")
(tab-new)
(tab-rename "email")
(tab-new)
(tab-rename "eshell")
#+end_src

Now, setup for some projects I am currently working on;
this section is volatile!
#+begin_src emacs-lisp
(tab-new)
(tab-rename "Thesis")
(tab-new)
(tab-rename "Thesis ꇚ")
(tab-new)
(tab-rename "Blog")
(tab-new)
(tab-rename "Blog ꇚ")
#+end_src

Finally, open a few “blank” tab as the rightmost,
for use when working on other/random things.
#+begin_src emacs-lisp
(tab-new)
(tab-rename "-")
(tab-new)
(tab-rename "-")
(tab-new)
(tab-rename "-")
#+end_src

*** Visit tabs and setup buffers

Now, let us visit the tabs, and set up the windows in them.
Since they're named (presumably uniquely),
we'll use ~tab-bar-switch-to-tab~ which takes a ~name~ argument.

My ~cascading-find-files~ sometime comes in handy here.

**** Consistent tabs

First, the ~init~ tab.
Here I want my Emacs init in my usual three window split
(two vertically split windows on the left, large single window on the right),
with the messages buffer on the lower left
and a help buffer preemptively opened in the upper right.
#+begin_src emacs-lisp
(tab-bar-switch-to-tab "init")
(find-file my/emacs-init)
(split-window nil nil 'left)
; describe symbol will use the window not in focus, so the left
(describe-symbol 'describe-symbol)
; switch to the help window on the left
(other-window 1)
(split-window nil nil 'above)
(switch-to-buffer "*Messages*")
#+end_src

My init file is part of my ~dotfiles~ repository.
In the tab for managing that repo,
I want my Emacs init on the left a magit buffer on the right.
#+begin_src emacs-lisp
(tab-bar-switch-to-tab "dotfiles ꇚ")
(find-file my/emacs-init)
(split-window nil nil 'right)
(magit-status-setup-buffer)
#+end_src

The ~Logs~ tab is similar, but has my supervisory report log
on the left and 
and my inbox on the right.
#+begin_src emacs-lisp
(tab-bar-switch-to-tab "Logs")
(find-file my/journal)
#+end_src

The ~email~ tab has a scratch file on the left
and my inbox on the right.
#+begin_src emacs-lisp
(tab-bar-switch-to-tab "email")
(find-file my/org-scratch)
(split-window nil nil 'left)
(mu4e-headers-search-bookmark (mu4e-get-bookmark-query ?i))
#+end_src

In the ~Shell~ tab, create buffers for three ~eshell~ instances
in the usual configuration. By passing a numeric argument,
we get unique buffers.
#+begin_src emacs-lisp
(tab-bar-switch-to-tab "eshell")
(eshell '3)
(split-window nil nil 'right)
(eshell '2)
(split-window nil nil 'below)
(eshell '1)
#+end_src

**** Volatile tabs

***** Thesis

My thesis involves Agda, so I want the Agda information buffer open.
I prefer that information buffer in the lower left,
the master file in the upper left, and the thesis directory on the right.
The ~git~ tab is setup the same way the ~Setup ꇚ~ tab is.
#+begin_src emacs-lisp
(let ((thesis-dir "~/projects/agda-computability/"))
  (let ((thesis-master (concat thesis-dir "thesis-master.org")))
    (tab-bar-switch-to-tab "Thesis")
    (find-file thesis-dir)
    (split-window nil nil 'right)
    (find-file thesis-master)
    (split-window nil nil 'above)
    (switch-to-buffer (agda2-info-buffer))

    (tab-bar-switch-to-tab "Thesis ꇚ")
    (find-file thesis-master)
    (split-window nil nil 'right)
    (magit-status-setup-buffer)))
#+end_src

***** Blog (and personal website)

For the moment, my ~Blog~ tab setup is similar to the thesis setup,
because I blog about Agda.
#+begin_src emacs-lisp
(let ((github-io-dir "~/projects/armkeh.github.io/"))
  (let ((github-io-main (concat github-io-dir "index.org")))
    (tab-bar-switch-to-tab "Blog")
    (find-file github-io-dir)
    (split-window nil nil 'right)
    (find-file github-io-main)
    (split-window nil nil 'above)
    (switch-to-buffer (agda2-info-buffer))

    (tab-bar-switch-to-tab "Blog ꇚ")
    (find-file github-io-main)
    (split-window nil nil 'right)
    (magit-status-setup-buffer)))
#+end_src

***** COMMENT Principles of Programming Languages

I use three tabs for my “Principles of Programming Languages”
course, 3mi3;
1. content production environment,
2. administration environment, and
3. ~git~ and website management environment.
#+begin_src emacs-lisp
(let* ((popl-dir "~/teaching/PoPL/")
       (popl-index (concat popl-dir "index.org")))
    (tab-bar-switch-to-tab "PoPL content")
    (find-file popl-dir)
    (split-window nil nil 'right)
    (split-window nil nil 'above)

    (tab-bar-switch-to-tab "PoPL ꇚ")
    (find-file popl-index)
    (split-window nil nil 'right)
    (magit-status-setup-buffer))

(let ((popl-admin-dir "~/teaching/PoPL-admin/"))
    (tab-bar-switch-to-tab "PoPL admin")
    (find-file popl-admin-dir)
    (split-window nil nil 'right)
    (magit-status-setup-buffer))
#+end_src

**** Focus on the first tab

#+begin_src emacs-lisp
(tab-select 1)
#+end_src

** IX work machine
:PROPERTIES:
:header-args:emacs-lisp: :tangle ~/dotfiles/emacs/ix-session.el
:END:

I context-switch a lot more frequently while at work,
so there are not a small handful of projects
that need to be opened every time I start up Emacs.

I do want various log and note files opened.
Other than that, open a few tabs with my aliases directory open,
which lets me quickly get into a directory for working.
#+begin_src emacs-lisp
(tab-rename "logs")
(tab-new)
(tab-rename "meetings")
(tab-new)
(tab-rename "p1")
(tab-new)
(tab-rename "p2")
(tab-new)
(tab-rename "p3")

(tab-bar-switch-to-tab "@3")
(find-file "~/@")
(tab-bar-switch-to-tab "@2")
(find-file "~/@")
(tab-bar-switch-to-tab "@1")
(find-file "~/@")

(tab-bar-switch-to-tab "meetings")
(find-file "~/logs/meetings/standup.org")
(split-window nil nil 'left)
(find-file "~/logs/meetings/one-on-ones.org")

(tab-bar-switch-to-tab "logs")
(find-file "~/logs/knowledge.org")
(split-window nil nil 'left)
(find-file "~/logs/scratch/org-scratch.org")
#+end_src

** Check identity of machine and load session

:TODO: Commentary.
:TODO: Be more helpful if the identity is unknown; perhaps button actions to set it properly?

#+begin_src emacs-lisp
(let ((machine-identity-file "~/.this-machine"))
  (if (file-exists-p machine-identity-file)
      (let ((this-machine (f-read-text "~/.this-machine")))
        (pcase (string-trim-right this-machine)
          ("personal" (load "~/dotfiles/emacs/personal-session.el"))
          ("ix"       (load "~/dotfiles/emacs/ix-session.el"))
          (otherwise  (message-box "Couldn't determine what this machine is for session setup. Put a correct identity in ~/.this-machine."))))
    ;; else, machine identity file doesn't exist
    (message "Init: Didn't find the machine identity file at ~/.this-machine, so don't know how to set up the session.")))
#+end_src

* Cleanup

** Check the contents of the (proper/system) init file

It is not uncommon for the Emacs init file to be modified
without my direct action;
either because of some setting change
I consent to without thinking about it,
or some well-meaning process making a change I presumably want.

It is for that reason that this file is not directly tangled to ~~/.emacs~.
Erasing those changes by re-writing the content
of that file every time I start Emacs is probably not what I actually want.

That said, I should be made aware of the fact that a change has been made;
either I will want to just undo the settings, or more likely, I will want
to migrate them to their proper place in this file.

Using the copy of the expected ~.emacs~ content which is tangled to ~/tmp/.emacs~ above,
this code checks the contents of ~~/.emacs~. If it is not as expected,
show a popup message and then displays a diff buffer to alert me to the changes.
#+begin_src emacs-lisp :noweb yes :results raw
(let* ((dotemacs-file "~/.config/emacs/init.el")
       (dotemacs-backup "/tmp/init.el")
       (dotemacs-contents
        (with-temp-buffer
          (insert-file-contents dotemacs-file)
          (buffer-string)))
       (dotemacs-expected
        (with-temp-buffer
          (insert-file-contents dotemacs-backup)
          (buffer-string))))
  (unless (equal dotemacs-contents dotemacs-expected)
    (message-box "~/.config/emacs/init.el content has been modified from my expected contents!\n\nOpening a diff buffer.")
    (diff dotemacs-file dotemacs-backup)))
#+end_src

Some notes about this:
- I initially attempted to accomplish this comparison by somehow
  comparing the text of the Emacs init file to the text of the
  ~src~ block above directly, avoiding the need to tangle that block to ~/tmp~.
  Unfortunately, I couldn't find a satisfying way to obtain the text
  of the ~src~ block in this file as a string.
  - Copying it manually raises issues if it ever changes, of course.
  - I could use noweb syntax to place its contents into this ~src~ block,
    but I could not make it a string, as it contains double quotes,
    and Emacs lacks a form for string literals.
    - I could convert it to a string using the ~string~ function,
      but then comments would be lost. I followed this line briefly anyway,
      trying to read in the contents of Emacs init file as Elisp code,
      and then compare the code instead of comparing strings.
      This gets a bit too complicated though and makes
      the difference reporting less satisfying, as it cannot show
      the actual file contents.

** Update the README file

:TODO: Check the buffer/window cleanup. Somehow this is causing a split if only one window was opened.

I want my README file for this directory
to be automatically kept up to date when changes are made.

First, an intermediate README is tangled from here.
Note that this by itself is not sufficient to act as the final README;
the ~include~ command will not be honoured by GitHub's Org rendering.
So this file is just an inbetween to allow us to export
the final version of the ~README.org~ file.
#+begin_src org :tangle ~/dotfiles/emacs/private/README-intermediate.org
#+Options: toc:nil tags:t timestamp:nil

# This file is tangled from emacs-init.org,
# and should not be modified directly.

This directory contains the files that make up my Emacs setup.

Below are the contents of my literate Emacs initialisation file.

See also my
- [[./yankpad.org][Yankpad snippets file]]
  - (Frequently used text expansions.)

,* Table of contents  :TOC_2:

,* The contents       :ignore:

#+include: ~/dotfiles/emacs/emacs-init.org
#+end_src

Now, we include in this file code
to automatically export the intermediate file to the final one;
this will run every time Emacs starts,
keeping the README up to date.
I will notice the file has changed when checking the Git repo status,
an regularly commit the changes.
#+begin_src emacs-lisp :results none
(let* ((readme-directory "~/dotfiles/emacs/")
       (readme-intermediate-filepath (concat readme-directory "private/README-intermediate.org"))
       (readme-final-filepath (concat readme-directory "README.org")))
  (with-temp-buffer
    ;; We need to visit the intermediate and final README files;
    ;; we will want to close them afterwards unless we were already visiting them.a
    (let ((was-already-visiting-intermediate (find-buffer-visiting readme-intermediate-filepath))
          (was-already-visiting-final        (find-buffer-visiting readme-final-filepath)))
      (find-file readme-intermediate-filepath)
      ;; Make a temporary save to the final filepath;
      ;; essentially copying the intermediate file to the final filepath.
      ;; Not doing this before exporting will break relative links
      ;; in the init file, as they will be prefixed with `../`.
      (write-file readme-final-filepath)
      ;; Export it to a new buffer; exporting expands the included files.
      ;; Do this quietly, without putting messages in the minibuffer.
      (let ((inhibit-message t))
        (org-org-export-as-org))
      ;; At the top, place a warning not to edit the file.
      (beginning-of-buffer)
      (insert "# This file is automatically generated by emacs-init.org.\n")
      (insert "# This file should not be modified directly.\n\n")
      ;; Now write it to a file.
      (write-file readme-final-filepath)
      ;; And clean up.
      (unless was-already-visiting-intermediate
        (kill-buffer (find-buffer-visiting readme-intermediate-filepath)))
      (unless was-already-visiting-final
        (kill-buffer (find-buffer-visiting readme-final-filepath))))))
#+end_src

*** Why not use markdown?

We could, instead of producing the ~README.org~ file,
just as easily produce a ~README.md~ file
by switching out the export command above.

In fact, for a while, I was producing a markdown file for the README.

But the setup for internal links in the markdown files
Org produces involve randomised link anchors,
so every time Emacs was started there were (uninteresting!)
changes to the README file, even if nothing had changed with
the init file itself.

So, we instead use an Org file for the README.

** Prompt before quitting Emacs

It's rare that I actually want to close Emacs, so it's not an annoyance
to prompt first; in fact, it's much preferred to accidentally closing.
#+begin_src emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+end_src
Note that the prompt is skipped if we already have a “do ~x~ before exiting?”
prompt, such as for saving some files.

This is the very last setting, because if we don't make it this far,
I want to be able to fix the error that stopped us reaching here
and quit without being hassled.
