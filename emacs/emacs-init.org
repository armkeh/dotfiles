#+Title: Mark Armstrong's literate emacs initialisation
#+Author: Mark Armstrong
#+Description: My (heavily organised) emacs initialisation settings,
#+Description: along with commentary, mostly to help me remember
#+Description: why things are set as they are.

* Introduction

** Preamble                                    :ignore:

This document is now in its second major version, having been
started over after it previously grew unwieldly.

This iteration focuses on a more carefully organisation of settings.
Rather than grouping settings by major mode or thematically,
they are grouped by importance.

This grouping allows me to easily reduce my settings to “bare bones”
when needed, without compromising the settings that are most important to me.
And it simplifies the “binary search” approach to debugging,
where we recursively disable roughly half the init file in order
to find the source of some bug.

For the sake of searching for settings via their “theme”,
I try to tag headings in this file.

** The file layout

- Simple cosmetics
  - Harmless cosmetic changes, that make the worst case of a
    crash during initialisation more comfortable.
    - Nothing that should affect performance.
  - Activate my themes.
  - Toggle the visual features that are significant,
    such as turning off scroll and menu bars.
- Vital
  - Activate packages I use near constantly, such as Org mode.
    - And change any settings for them that are vital.
  - Establish my frequent shortcuts.
- Near vital
  - Support for programming language specific modes.
  - 
- Tab and window setup

* Deprecation list                              :TODO:

These settings were deprecated when I migrated to this version.
Sometime soon I should check them over and decide whether
to retire them for good, or fit them in here.
- Smooth scrolling
  - (Not certain that ever worked well.)
- ~~/dotfiles/emacs/downloaded-packages~
  - Do I need these at all?

* How to use this file

I don't like to export this file to ~~/.emacs~, since that file
may be modified by Emacs itself or sometimes other programs.
I like to keep that file a bit bare so I can catch any changes
made to it by entities other than myself.

So instead, I create a symbolic link to this file in ~~/.emacs.d/~,
then add to ~~/.emacs~ these lines:
#+name: dotemacs-expected-elisp
#+begin_src emacs-lisp :tangle /tmp/.emacs
;; BEGIN my edits

;; Enable editing of version controlled files through symlinks.
;; Usual setting is to ask, which means asking each time my init is opened
;; since I use a symlink to it.
(setq vc-follow-symlinks t)

;; Delete the old tangled and compiled init file.
;; Shouldn't be necessary, but better safe than sorry.
(delete-file "~/.emacs.d/emacs-init.el")
(delete-file "~/.emacs.d/emacs-init.elc")

;; Load my init file.
(org-babel-load-file "~/.emacs.d/emacs-init.org")

;; END my edits
#+end_src

In [[Cleanup]] below, we check the contents of the ~~/.emacs~ file against this,
to warn me if changes are made. Hence why it is tangled to the ~/tmp~ directory.

* Environment setup and package management

Before we really begin, we ensure environment settings are correct
and setup ~use-package~ as a package manager.

** Make sure we have the right PATH

See https://github.com/purcell/exec-path-from-shell
#+begin_src emacs-lisp
(use-package exec-path-from-shell)
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+end_src

** Basic package management

~package~ gives us the basic tools to add packages from repositories
to Emacs.
#+begin_src emacs-lisp
(require 'package)
#+end_src

We will shortly setup a package manager to ease installation of packages.

** Set package repositories

By default, the only package repository is the ELPA repo.
See the list of packages contained therein [[http://elpa.gnu.org/packages/][here]].

Here we add the MELPA repo and the NonGNU repo,
then refresh to get the latest contents.
#+begin_src emacs-lisp
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("nongnu" . "https://elpa.nongnu.org/nongnu/"))
(package-initialize)
(package-refresh-contents)
#+end_src

If needed, we can set ~package-archive-priorities~
to set the priority for these repositories.

Older versions of Org and the “Org+Contrib” package were hosted at
http://orgmode.org/elpa/,
but after Org 9.5, they are no longer distributed there.
Now Org is best available though GNU ELPA, and there is a new
“Org-Contrib” package available through NonGNU ELPA
(the + was dropped from the name.)

** A package manager – ~use-package~ 

The ~use-package~ package provides an easy-to-use interface
to install and customise packages.

I generally use it just to avoid having to ~package-install~ packages
whenever I migrate systems.
I haven't properly learned how to customise packages using it;
generally I just write my customisations as plain Elisp
after the ~use-package~ invocation to install them.
Where you see me use ~use-package~ to apply customisations,
I have probably copied someone else's initialisation.

Unless it's already installed, update the packages archives,
then install the most recent version of “use-package”.
#+begin_src emacs-lisp
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

(require 'use-package)
#+end_src

I always want to download packages that aren't installed.
#+begin_src emacs-lisp
(setq use-package-always-ensure t)
#+end_src

** Update packages

For the moment, I use the ~auto-package-update~ to automatically update
packages for me.
#+begin_src emacs-lisp
(use-package auto-package-update
  :config
  ;; Delete residual old versions
  (setq auto-package-update-delete-old-versions t)
  ;; Do not bother me when updates have taken place.
  (setq auto-package-update-hide-results t)
  ;; Update installed packages at startup if there is an update pending.
  (auto-package-update-maybe))
#+end_src

* Elisp utilities

These utility packages simplify many families of tasks.

~s~ is for ~s~-tring management.
#+begin_src emacs-lisp
(use-package s)
#+end_src

~f~ is for ~f~-ile management.
#+begin_src emacs-lisp
(use-package f)
#+end_src

* Custom Elisp

Some of this code may be moved to separate files later,
but it's small and collected here for now.

** Toggle themes

These functions allow me to clear and toggle my themes.
#+begin_src emacs-lisp
(defun disable-all-custom-themes ()
  "Disable all custom themes.
   Returns the previous highest precendence theme
   (nil if no themes were previously enabled).

   Implementation:
     Gets the highest precedence applied theme as the first element
     of custom-enabled-themes.

     Then iteratively disables all the themes in custom-enabled-themes.
  "
  (let ((most-recent-theme (car custom-enabled-themes)))
    (while (car custom-enabled-themes)
      (disable-theme (car custom-enabled-themes)))
    most-recent-theme))

(defun toggle-my-themes ()
  "Disable all custom, then try to toggle the themes
   my-dark-theme and my-light-theme, in that if one was
   the last applied theme, the other will be applied.

   If neither was the last applied theme, my-dark-theme
   will be applied as a default.
  "

  (let ((most-recent-theme (disable-all-custom-themes)))
    (if (eq most-recent-theme my/dark-theme)
        (load-theme my/light-theme t)
        (load-theme my/dark-theme t))))
#+end_src

** Theme change hook

[[https://www.reddit.com/r/emacs/comments/4v7tcj/][Apparently]],
there is no hook in Emacs for when a theme change occurs.
This code snippet, taken from the linked reddit post, defines one I can use.
#+begin_src emacs-lisp
(defvar after-load-theme-hook nil
  "Hook run after a color theme is loaded using `load-theme'.")
(defadvice load-theme (after run-after-load-theme-hook activate)
  "Run `after-load-theme-hook'."
  (run-hooks 'after-load-theme-hook))
#+end_src

** Cascading window setup

I set up my default desktop using a “cascading pattern”,
moving from larger windows in the upper right to
smaller windows in the lower left.

This works best with 2 or 3 windows, but it can be used for more.

The process is:
- If there are two or more files left to open:
  - Create a new window to the left.
  - Open the next file.
  - Move the focus to the left.
  - If there are two or more files left to open:
    - Create a new window below.
    - Open the next file.
    - Move focus down.
- Else if there is one file left to open,
  open it.
- Else, quit.
#+begin_src emacs-lisp
(defun cascading-find-files (files)
  "Opens a set of files in a cascading series of windows,
created by splitting the current window.
The windows begin in the upper right, with the first file,
and move left and then down, each window being half the size
of the previous (as long as this is possible)."
  (while files ;; there's at least one file to open
    (find-file (car files))
    (setq files (cdr files))
    (when files ;; there are two or more files
      (split-window nil nil 'left)
      (other-window 1)
      (find-file (car files)) ;; open second file on the left
      (setq files  (cdr files))
      (when files ;; there are still more files, so split horizontally
        (split-window nil nil 'below)
        (other-window 1)))))
#+end_src

:TODO: Create a alternate method for vertical screens, preferably also allowing on-the-fly switching between the two setups.

** Killing a buffer when its associated process finishes

When starting an asynchronous process using ~async-shell-command~,
a buffer is created and brought into focus in another window
to show the output of the command.

We can use ~start-process~ or other functions to start
asynchronous processes without bringing into display,
if that's desired. Instead of that though,
I often want to see the output,
but don't want the buffer to remain once the process
has finished.

This function can be assigned to a sentinel for a process
to kill its associated buffer when the process finishes.
#+begin_src emacs-lisp
(defun kill-buffer-on-process-finish (process signal)
  (when (memq (process-status process) '(exit signal))
    (kill-buffer (process-buffer process))
    (shell-command-sentinel process signal)))
#+end_src

* Simple cosmetics

** First: disable the splashscreen and find the my emacs init file

This way, if something goes wrong below, I am positioned to fix it
right away.
#+begin_src emacs-lisp
(setq inhibit-splash-screen t)
(setq my/emacs-init-file "~/.emacs.d/emacs-init.org")
(find-file my/emacs-init-file)
#+end_src
This file will be closed and re-opened below, to ensure
all cosmetic changes show correctly.

** Disable unnecessary interface elements

I don't use the menubar, toolbar (icons usually below the menu),
or scroll bars.
#+begin_src emacs-lisp
(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

** Fonts

I like the Cousine font, and usually use a small 11in screen,
and so use a small font; 9pt seems to be a sweet spot.
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist
             '(font . "Cousine-9"))
#+end_src

** Line and column information

*** Line numbers

As of Emacs 26, ~display-line-numbers-mode~ is the “proper”
way to display line numbers next to a buffer.
(Before 26, ~linum-mode~ was the usual method.)
#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'display-line-numbers-mode)
(add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src
Line numbers are distruptive in some other modes,
hence why set them to show only in ~text-mode~ and ~prog-mode~ above.
To enable them globally, one would use ~global-display-line-numbers-mode~.

I find it concerning when the width of the column
used for line numbers grows throughout the document;
it makes me think Org mode headlines further down are nested.
Setting ~display-line-numbers-width-start~ causes the system
to count the number of lines when opening a buffer, and
set the minimum width necessary to display all line numbers.
It wastes some screen space, but is good for my sanity.
#+begin_src emacs-lisp
(setq display-line-numbers-width-start t)
#+end_src

*** Fill column display

Traditionally, it's good style to keep lines under 80 characters wide.
I follow this tradition (though recently some argue the amount should be increased.)

The (as of Emacs 27) built in ~display-fill-column-indicator-mode~ puts a ruler,
by default at 70 characters.
#+begin_src emacs-lisp
(global-display-fill-column-indicator-mode t)
#+end_src

Note that with ~org-indent-mode~, the ruler will be off
by the length of the indentation (i.e. it will be
at line 68 if indented 2 characters, 66 if indented 4, etc).
That's okay; the ruler is there as a reminder more than a firm guideline.

Prior to Emacs 27, ~fci-mode~ could be used for this purpose,
but I found it to cause noticable lag.
Using ~whitespace-mode~ to highlight lines exceeding a certain number
of characters was my preferred approach at that time.

** Themes

I use Protesilaos Stavrou's [[https://protesilaos.com/modus-themes/][Modus themes]], which
“[conform] with the highest standard for colour contrast
 between background and foreground values”. 
Prior to this I used the ~vibrant~ and ~nord-light~ themes
from [[https://github.com/hlissner/emacs-doom-themes][doom-themes]], but the Modus don't leave me desiring any other themes.
#+begin_src emacs-lisp
(use-package modus-themes)
#+end_src

By default, I prefer the dark ~modus-vivendi~,
but like to toggle between it and the light ~modus-operandi~ at need.
#+begin_src emacs-lisp
(setq my/dark-theme 'modus-vivendi)
(setq my/light-theme 'modus-operandi)

(load-theme my/dark-theme t)
#+end_src

** Highlight matching delimters

*** Highlight matching delimiters

It's useful to highlight the matching delimiter when the cursor
is on its match, especially when coding in Lisps.
#+begin_src emacs-lisp
(show-paren-mode 1)
#+end_src

Since I use ~rainbow-delimiters~ (setup below) it's actually distinctive
to colour the matching delimiter in plain white,
rather than the default red.
In case we're in a light theme though, set the background
to be black.
#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(show-paren-match ((t (:foreground "white"
                         :background "black"
                         :weight ultra-bold)))))
#+end_src

** Kill the open init buffer and reopen it

To ensure all these cosmetic changes are picked up,
kill my init buffer that we opened earlier and reopen it.
#+begin_src emacs-lisp
(kill-buffer "emacs-init.org")
(find-file my/emacs-init-file)
#+end_src

* Vital settings

** User information

#+begin_src emacs-lisp
(setq user-full-name "Mark Armstrong")
(setq user-mail-address "markparmstrong@gmail.com")
#+end_src

** Set a “custom” file

Emacs will, by default, insert all sorts of “custom” settings
into our ~.emacs~ file (or whichever of the default init locations we use),
especially those set via GUIs.

In order to avoid polluting that file, let's set it to use
a particular one. In fact, let's put it under my version control,
so I will be more able to notice changes to it.
#+begin_src emacs-lisp
(setq custom-file "~/dotfiles/emacs/custom.el")
(ignore-errors (load custom-file))
#+end_src

** Set a directory for non-package manager managed elisp files

This directory is for elisp files I develop myself
or that I download without use of a package manager.

This form is used, instead of ~add-to-load-path~,
so that subdirectories are searched.
See https://www.emacswiki.org/emacs/LoadPath
This is useful so that git repositories can be added here
as subtrees in this directory, and the ~.el~ files will be picked up.
#+begin_src emacs-lisp
(let ((default-directory  "~/dotfiles/emacs/elisp"))
  (normal-top-level-add-subdirs-to-load-path))
#+end_src

** Automatically revert unchanged files which change on the disk

Ideally this helps us avoid conflicts, in case I edit open files elsewhere.
Note reverting will not take place if there are unsaved changes,
so this is relatively safe.
#+begin_src emacs-lisp
(global-auto-revert-mode t)
#+end_src

I do use automatic syncing tools and sometimes work on other systems;
conflicts can still happen if one system is offline or the syncing
gets behind some other way, but with automatic reverts
it's less likely I trip over my own changes.

** Set what characters qualify as delimiters

*** Angle brackets are not delimiters to me

First, don't treat angle brackets as delimiters; even when writing
HTML or XML, I don't want them to qualify as delimiters for
the purpose of ~show-paren-mode~, ~check-paren~ and ~rainbow-delimiters~.
Treat them as symbols instead (this is the meaning of ~_~ in the
syntax table).
#+begin_src emacs-lisp
(defun my/<>-symbol-syntax ()
  (modify-syntax-entry ?> "_")
  (modify-syntax-entry ?< "_"))
#+end_src

~modify-syntax-table~ works on the current buffer
(unless given a buffer as optional argument)
and so we need to apply those modifications in each buffer.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'my/<>-symbol-syntax)
(add-hook 'prog-mode-hook 'my/<>-symbol-syntax)
(add-hook 'text-mode-hook 'my/<>-symbol-syntax)
#+end_src

The ~org-mode~ function modifies the entries when run,
and ~yankpad~ runs it regularly (albeit in a temporary buffer,
but the modification “leaks”), so we need to undo those
modifications.
#+begin_src emacs-lisp
(defadvice org-mode (after override-<>-syntax activate)
  (my/<>-symbol-syntax))
#+end_src

Side note: I'm honestly uncertain if the “leaking” of
the syntax entry modifications from temporary buffers is a bug.
It's likely just unintuitive behaviour.
It can be observed easily; just modify the entry for i.e. ~<~,
# matching >, just in case
and evaluate
#+begin_example emacs-lisp
(with-temp-buffer
  (org-mode))
#+end_example
and observe your modifications are undone.

*** These unicode characters are delimiters

Do treat these unicode symbols as delimiters.
The first character in each entry means either
- “open delimiter”, if it's a ~(~, or
- “close delimiter”, if it's a ~)~.
The second symbol designates the matching delimiter. 
#+begin_src emacs-lisp
(defun my/unicode-delimiter-syntax ()
  (modify-syntax-entry (string-to-char "⟨") "(⟩")
  (modify-syntax-entry (string-to-char "⟩") ")⟨")
  (modify-syntax-entry (string-to-char "⟪") "(⟫")
  (modify-syntax-entry (string-to-char "⟫") ")⟪")
  (modify-syntax-entry (string-to-char "⟦") "(⟧")
  (modify-syntax-entry (string-to-char "⟧") ")⟦")
  (modify-syntax-entry (string-to-char "⁅") "(⁆")
  (modify-syntax-entry (string-to-char "⁆") ")⁅")
  (modify-syntax-entry (string-to-char "｛") "(｝")
  (modify-syntax-entry (string-to-char "｝") ")｛")
  (modify-syntax-entry (string-to-char "“") "(”")
  (modify-syntax-entry (string-to-char "”") ")“"))
#+end_src

Apply those syntax entry modifications.
#+begin_src emacs-lisp
(add-hook 'prog-mode-hook 'my/unicode-delimiter-syntax)
(add-hook 'text-mode-hook 'my/unicode-delimiter-syntax)
#+end_src

** Always use spaces instead of tabs

#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil)
#+end_src

** Turn off electric indent mode

I don't use this or appreciate its interference.
#+begin_src emacs-lisp
(electric-indent-mode -1)
#+end_src

* Vital modes and their vital settings

** Org mode

*** Preamble

I use Org for almost everything, and utilise many
of the extras included in ~org-contrib~ (previously ~org-plus-contrib~.)
#+begin_src emacs-lisp
(use-package org
  :ensure org-contrib
  :config
  (require 'ox-extra))
#+end_src

*** Literate programming

:TODO: Check over the Org literate programming section.

**** Execution

By default, Emacs will query whether we /actually/ want to
execute code when we evaluate a code block. Also, it seems to
just /not/ execute code marked for execution during export in an
~org~ file. So, I remove the safety.
#+Name: evaluate-no-confirm
#+begin_src emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+end_src

By default only emacs lisp can be evaluated.
Documentation [[https://orgmode.org/manual/Languages.html][here]].

These languages have support built-in, it just has to be activated.
#+Name: evaluate-languages
#+begin_src emacs-lisp
(require 'ob-shell)
(require 'ob-haskell)
(require 'ob-latex)
(require 'ob-C)
(require 'ob-ruby)
(require 'ob-plantuml)
(require 'ob-R)
(require 'ob-ditaa)
(require 'ob-scheme)
(require 'ob-dot)
(require 'ob-python)
(require 'ob-js)
(require 'ob-clojure)
#+end_src

#+Name: evaluate-ditaa-path
#+begin_src emacs-lisp
(setq org-ditaa-jar-path "/usr/bin/ditaa")
#+end_src

#+Name: evaluate-geiser-implementation
#+begin_src emacs-lisp
;;(setq geiser-default-implementation 'guile)
#+end_src

For other languages, separate packages are needed.
#+Name: evaluate-fsharp
#+begin_src emacs-lisp
;;(use-package ob-fsharp)
#+end_src

~ob-oz~ comes with a Mozart2 installation;
if there's a problem, make sure the Mozart2 Elisp directory
is in the path.
#+Name: evaluate-oz
#+begin_src emacs-lisp
;;(require 'ob-oz)
#+end_src

There are at least two packages for Org babel support for Racket,
but neither are on MELPA. Neither one seems to stand out as
more or less fully featured.
- [[https://github.com/hasu/emacs-ob-racket][emacs-ob-racket]]
  is more recently maintained.
- [[https://github.com/xchrishawk/ob-racket][ob-racket]]
  has not been updated in 4 years.
So I choose ~emacs-ob-racket~. For the moment, I just saved it
to my ~emacs.d~; probably it should be put somewhere better,
but I will do that when I next set up my system 😀.
#+Name: evaluate-racket
#+begin_src emacs-lisp
;;(add-to-list 'load-path "/home/markparmstrong/.emacs.d/ob-racket")
;;(require 'ob-racket)
#+end_src

For shell code, we need to initialise via this function.
See [[https://emacs.stackexchange.com/questions/37692/how-to-fix-symbols-function-definition-is-void-org-babel-get-header][here]].
#+Name: evaluate-shell-init
#+begin_src emacs-lisp
(org-babel-shell-initialize)
#+end_src

PlantUML requires we set the path to the ~.jar~ file.
#+Name: evaluate-plantuml-path
#+begin_src emacs-lisp
(setq org-plantuml-jar-path "/usr/share/java/plantuml.jar")
#+end_src

~ob-typescript~ is [[https://github.com/lurdan/ob-typescript][available]].
#+begin_src emacs-lisp
(use-package ob-typescript)
#+end_src

~ob-ammonite~ interacts with the ~ammonite~ REPL for ~scala~.
#+begin_src emacs-lisp
(use-package ob-ammonite)
#+end_src
Note that the ~scala~ source blocks are marked as ~amm~ source,
not actually ~scala~. See
[[https://github.com/zwild/ob-ammonite][the documentation]].

This is not the right place to dump this,
but this code should cause the ~amm~ blocks to export as ~scala~ blocks
in LaTeX so ~minted~ knows how to handle them.
This code inspired by a similar problem solved on
[[https://emacs.stackexchange.com/a/19941][StackExchange]].
#+begin_src emacs-lisp
(defun my/ammonite-src-to-scala-src (text backend info)
  "Translate Ammonite minted blocks resulting from LaTeX export
to Scala minted blocks."
  (when (org-export-derived-backend-p backend 'latex)
    (with-temp-buffer
      (insert text)
      (goto-char (point-min))
      (replace-regexp "\\(\\\\begin{minted}.*\\){amm}" "\\1{scala}")
      (buffer-substring-no-properties (point-min) (point-max)))))

(add-hook 'org-export-filter-src-block-functions 'my/ammonite-src-to-scala-src)
#+end_src

#+begin_src emacs-lisp
(setq org-babel-clojure-backend 'cider)
(use-package cider)
(setq cider-default-repl-command "lein")
#+end_src

**** Editing source code

When I choose to edit a source block in a separate buffer,
that source block becomes my main focus.
So, open a new frame (OS window) in which to edit.
Then I can open other material, help buffers, etc.,
without disturbing the window setup around my Org window.
When I finish editing, that frame is killed.
#+begin_src emacs-lisp
(setq org-src-window-setup 'other-frame)
#+end_src
Note, I didn't think I would like the ~other-frame~ option
at all at first, but it grew on me when I realised
it was the best way to ensure that editing source blocks in
a separate buffer would not mess up my window layout
—which ~other-window~ fails to do—
give me the option at least to keep the Org buffer visible
—which ~current-window~ of course disables—
and give me enough room for the source buffer
—which ~split-window-below~ and ~split-window-right~ fail to do
on small screens.

When we open a new window to edit source blocks
the major mode of that window is determined by
the setting for the language in ~org-src-lang-modes~.
Override the setting in that attribute list if you wish to
change the major mode for a particular language.

It's convenient to have ~<tab>~ act as it would in the source language
when editing code blocks in the Org buffer.
However, for some reason I have found this irritating
and disabled it.
#+begin_src emacs-lisp
;;(setq org-src-tab-acts-natively t)
#+end_src

:TODO:
#+begin_src emacs-lisp
(setq org-src-fontify-natively t)
#+end_src

*** Other

:TODO: Check over and probably refile.

**** Inline tasks

#+begin_src emacs-lisp
(require 'org-inlinetask)
#+end_src

** Sending email: ~send-mail~

:TODO: Check for cleanup of send-mail settings.

#+begin_src emacs-lisp
(setq mail-user-agent 'mu4e-user-agent)
#+end_src

Whether or not you use Emacs to read your email,
you can use it to send emails with the builtin ~send-mail~.
It can be configured to use your OS default for sending email
(for instance, through a mail program or browser),
or configured to send mail itself (for instance via SMTP).
For convenience, I choose the latter.

I use Gmail exclusively, so the setup is small.
#+begin_src emacs-lisp
(require 'smtpmail)

(setq message-send-mail-function 'smtpmail-send-it
   starttls-use-gnutls t
   smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
   smtpmail-auth-credentials
     '(("smtp.gmail.com" 587 "markparmstrong@gmail.com" nil))
   smtpmail-default-smtp-server "smtp.gmail.com"
   smtpmail-smtp-server "smtp.gmail.com"
   smtpmail-smtp-service 587)
#+end_src

#+begin_src emacs-lisp
(require 'auth-source)
(setq auth-sources '((:source "~/.authinfo.gpg")))
#+end_src

If needed, we can create a queue to allow for sending of email
while offline. See
[[https://www.gnu.org/software/emacs/manual/html_node/smtpmail/Queued-delivery.html][the documentation]].
#+begin_src emacs-lisp
;;(setq smtpmail-queue-mail nil)
#+end_src

After sending an email, kill the buffer.
#+begin_src emacs-lisp
(setq message-kill-buffer-on-exit t)
#+end_src

*** Sending HTML mail

I usually prefer to send plaintext email, but if I want to send
HTML for any reason, that can be done from Emacs as well.

~org-mime~ allows sending of HTML emails written in Org markdown;
I don't use it yet, as I only send plaintext, but it may be handy later.
#+begin_src emacs-lisp
(use-package org-mime)
#+end_src

** Reading email: ~mu4e~ (with isync)

:TODO: Check for cleanup of mu4e settings.

Using Emacs as an email client provides us with powerful text editing
while composing email.

I initially followed the guide
[[https://www.reddit.com/r/emacs/comments/bfsck6/mu4e_for_dummies/][from this reddit post]]
to set it up, but I've customised things heavily at this point.

#+begin_src emacs-lisp
(add-to-list 'load-path "/usr/share/emacs/site-lisp/mu4e")
(require 'mu4e)
#+end_src

*** Basic setup

**** The mail directories

~mu4e~ needs to know where my mail directory lives,
and the paths of certain important mailboxes relative to that.
Note that there should be an archive box here, but I don't make
use of an archive mailbox.
#+begin_src emacs-lisp
(setq
  mu4e-maildir       "~/.mail/gmail"
  mu4e-drafts-folder "/Drafts"
  mu4e-sent-folder   "/Sent Mail"
  mu4e-trash-folder  "/Trash")
#+end_src

**** Get mail command

I use isync (whose executable is called ~mbsync~) to manage
my local mail directory.

I have two groups set up in my ~mbsyncrc~; one smaller group
of my most important Gmail labels
which synchronises with the remote quickly,
and a larger group of the remaining labels which takes
a fair chunk of time to synchronise.
The ~mu4e~ get mail command uses the former, to ensure
it does not take an excessive amount of time when I manually run it.
#+begin_src emacs-lisp
(setq mu4e-get-mail-command "mbsync gmail-quick")
#+end_src

:TODO: Is background updating working again?
# ~mu4e~ is supposed to be able to run the get mail command
# and index the mail at set intervals.
# Unfortunately, this process seems to silently fail somewhere.
# So I disable the automatic updating and instead
# register my own idle timers to update mail.
# #+begin_src emacs-lisp
# (setq mu4e-update-interval nil)
# #+end_src

**** COMMENT Updating while idle

Here we register a function which updates mail
to be run when the system is idle.

We set it so that every fifth time the function is run,
all mail is synced.
The other times, only my quick channel is synced.

We need a ticker variable to accomplish this.
#+begin_src emacs-lisp
(defvar my/mu4e-update-ticker 0
  "Ticker variable for use with `my/mu4e-get-mail-command`.
   Once a certain value is reached, sync all mail
   and reset the ticker.")
#+end_src

This function locally overrides ~mu4e-get-mail-command~ and
then invokes ~mu4e-update-mail-and-index~ (running in the background)
#+begin_src emacs-lisp
(defun my/mu4e-update-mail-and-index (the-command)
  "Run `mu4e-update-mail-and-index` after setting
   a custom `mu4e-get-mail-command`."
  (let ((mu4e-get-mail-command the-command))
    (mu4e-update-mail-and-index t)))
#+end_src

Now we use the above function and ticker in the lambda
we register on an idle timer.
#+begin_src emacs-lisp
(run-with-idle-timer 600 t (lambda ()
  (if (< my/mu4e-update-ticker 4)
      (progn (setq my/mu4e-update-ticker (+ my/mu4e-update-ticker 1)) 
             (my/mu4e-update-mail-and-index mu4e-get-mail-command))
      (progn (setq my/mu4e-update-ticker 0)
             (my/mu4e-update-mail-and-index "mbsync -a")))))
#+end_src

# This is a bit of a dumb asynchronous process to update the rest of
# the mailboxes. Dumb in the sense that if anything ever goes wrong,
# I won't know about it.
# #+begin_src emacs-lisp
# (start-process "mbsync-gmail-rest"
#                "*mbsync gmail-rest*"
#                "~/dotfiles/emacs/mbsync-gmail-rest")
# #+end_src
# It runs this shell process.
# #+begin_src shell :tangle mbsync-gmail-rest :shebang "#!/bin/bash"
# while :
# do
#   echo "Beginning sync"
#   date
#   mbsync gmail-rest
#   echo ""
#   echo "Indexing with mu"
#   mu index -m ~/.mail/gmail
#   echo "Ended sync, sleeping for 30m"
#   echo ""
#   echo ""
#   echo ""
#   sleep 30m
# done
# #+end_src
# By default, we would be prompted whether we want to kill this process
# upon exiting Emacs; I will always answer yes, so it's best
# just not to have it ask.
# #+begin_src emacs-lisp
# (set-process-query-on-exit-flag (get-process "mbsync-gmail-rest") nil)
# #+end_src

~mu4e~ has an annoying habit of hogging the minibuffer while
updating and indexing; unfortunately this means I prefer
to silence its updating and indexing messages.
#+begin_src emacs-lisp
(setq mu4e-hide-index-messages t)
#+end_src

~mu/mu4e~ normally keeps the base filename the same when moving
mail to a different folder; with isync, it works better to
change the name. See the documentation of this variable.
#+begin_src emacs-lisp
(setq mu4e-change-filenames-when-moving t)
#+end_src

*** Viewing emails

**** Email list

This controls the information shown in the email lists.
- ~:human-date~ will show the time if the email was sent today
  (the alternative, ~:date~, would not).
- ~:from-or-to~ is a special field that will show the sender if it was not me;
  otherwise it will show the recipient.
#+begin_src emacs-lisp
(setq mu4e-headers-fields
    '( (:date       . 22)
       (:flags      . 4)
       (:from-or-to . 22)
       (:subject    . nil)))
#+end_src

#+begin_src emacs-lisp
(setq mu4e-headers-date-format "%d %b/%y, %a, %R")
#+end_src

Don't organise by threads; I find organising by date preferable.
#+begin_src emacs-lisp
(setq mu4e-headers-show-threads nil)
#+end_src
This can be toggled with `P` in the email list.

By default, related mail is also included; for instance,
if I reply to a message in a list, the reply will show up in the list.
I find this unintuitive, especially since I don't organise by threads.
#+begin_src emacs-lisp
(setq mu4e-headers-include-related nil)
#+end_src

**** Individual mail

Show images by default, and prefer to use ~imagemagick~ to do so.
#+begin_src emacs-lisp
(setq mu4e-view-show-images t)

(when (fboundp 'imagemagick-register-types)
  (imagemagick-register-types))
#+end_src

Attachments can simply be placed in ~~/Downloads~;
I usually share this directory from ChromeOS, which makes it convenient
to put attachments there (so I can open them in both OSes easily).
#+begin_src emacs-lisp
(setq mu4e-attachment-dir  "~/Downloads")
#+end_src

Show full email addresses when viewing messages.
#+begin_src emacs-lisp
(setq mu4e-view-show-addresses 't)
#+end_src

**** HTML support

Emacs is not the ideal environment to read HTML emails;
for that reason, if there is a plaintext version available,
I prefer to see that first.
#+begin_src emacs-lisp
(setq mu4e-view-prefer-html nil)
#+end_src

If there is no plaintext available, or if the plaintext is unbearable
for any reason, we can open emails in the browser by using
this shortcut.
#+begin_src emacs-lisp
(add-to-list 'mu4e-view-actions
  '("ViewInBrowser" . mu4e-action-view-in-browser) t)
#+end_src

*** Shortcuts to mailboxes and bookmarks

#+begin_src emacs-lisp
(setq mu4e-maildir-shortcuts
    '(("/Inbox"     . ?i)
      ("/Sent Mail" . ?s)
      ("/Desk/Followup"  . ?f)
      ("/Desk/Reference" . ?r)
      ("/Desk/Transient" . ?t)))
#+end_src

Bookmarks can be used from the ~mu4e~ main page,
and are also useful for programmatically jumping to maildirs.
#+begin_src emacs-lisp
(add-to-list 'mu4e-bookmarks
  (make-mu4e-bookmark
    :name  "Inbox"
    :query "maildir:/Inbox"
    :key ?i))
#+end_src

*** ~mu4e-maildirs-extension~

The package ~mu4e-maildirs-extension~ causes the display of
the read/total count for each mail directory in the list.
#+begin_src emacs-lisp
(use-package mu4e-maildirs-extension)

(mu4e-maildirs-extension)
#+end_src

*** Message composition settings

I don't use a signature.
#+begin_src emacs-lisp
(setq mu4e-compose-signature-auto-include nil)
#+end_src

Don't automatically insert line breaks for long lines
in the message buffer! Such settings infuriate me.
#+begin_src emacs-lisp
(add-hook 'mu4e-compose-mode-hook 'turn-off-auto-fill)
#+end_src

**** Contacts

I've had problems where contact completion breaks.
For the moment, I make sure that the contacts are requested
from ~mu~ upon starting Emacs.
This function in particular was undefined on one of my systems,
so first check it is defined as a function.
#+begin_src emacs-lisp
(when (fboundp 'mu4e~request-contacts)
  (mu4e~request-contacts))
#+end_src

Note that the contacts are stored in a hash table,
and so I am unsure of how to actually see them in Emacs.

**** Flow

I write emails the way I write all my documents:
trying as best I can to respect a maximum line length of 80 characters.
But even 80 characters can be too wide on some mobile screens,
and when I enter my linebreaks, the receiving client may turn this
#+begin_src text
A line with a number of characters that is possibly too wide for mobile.
Another line of a decent length.
#+end_src
into this
#+begin_src text
A line with a number of characters that is possibly
too wide for mobile.
Another line of a decent length.
#+end_src

One option to solve seems to be to use long paragraphs and to
send messages with ~format=flowed~, which tells the receiving client
to reflow paragraphs as needed.
See for instance [[https://www.emacswiki.org/emacs/FormatFlowed]].
But this has two downsides: I dislike writing long lines,
even with autofill.
And ~format=flowed~ is not supported consistently;
for instance Gmail does not respect it.

I don't have a solution for this potential problem yet,
so I choose to do nothing,
and potentially have my emails flow broken on mobile screens.

# It is useful to reflow my text for the reciever.
# The ~format=flowed~ is supposed to allow the receiving client
# to do this.
# #+begin_src emacs-lisp
# (setq mu4e-compose-format-flowed t)
# #+end_src
# But since some clients don't support ~format-flowed;~ Gmail being
# the notable example, instead reflow paragraphs into long lines,
# which should be broken as needed by the receiver.
# #+begin_src emacs-lisp
# (add-hook 'mu4e-compose-mode-hook (lambda () (use-hard-newlines -1)))
# #+end_src
#
# It's convenient not to reply to myself by default.
# #+begin_src emacs-lisp
# (setq mu4e-compose-dont-reply-to-self t)
# #+end_src

**** HTML support (nothing to see here)

Note that there is a ~org-mu4e~ package that comes with ~mu4e~,
which would allow for sending HTML email using ~mu4e~,
but it is apparently depricated.
The ~org-mime~ package above is probably the correct path
if I ever want to send HTML emails.

**** Changing the ~From~ address automatically

I use my personal Gmail to collect all of my emails,
but when replying I like to send back from whichever
account the original mail was sent to.
This hook updates the ~From~ field when replying to
an email sent to one of my other accounts.
It is taken from [[https://www.djcbsoftware.nl/code/mu/mu4e/Compose-hooks.html#Compose-hooks][the ~mu4e~ documentation]],
with a modification to save the existing ~user-mail-address~ so
that it can be reset afterwards.
#+begin_src emacs-lisp
(add-hook 'mu4e-compose-pre-hook
  (defun my/set-from-address ()
    "Set the From address based on the To address of the original."
    (let ((msg mu4e-compose-parent-message))
      (when msg
        (setq my/user-mail-address-backup user-mail-address)
        (setq user-mail-address
          (cond
             ((mu4e-message-contact-field-matches msg :to "armstmp@mcmaster.ca")
               "armstmp@mcmaster.ca")
             ((mu4e-message-contact-field-matches msg :cc "armstmp@mcmaster.ca")
               "armstmp@mcmaster.ca")
             (t
               "markparmstrong@gmail.com")))))))
#+end_src

The ~mu4e-compose-mode-hook~ runs
after the message has been formed.
So we are safe to restore the original ~user-mail-address~.
#+begin_src emacs-lisp
(add-hook 'mu4e-compose-mode-hook
  (defun my/restore-user-mail-address ()
    "Restore the user-mail-address based on the value
     in my/user-mail-address-backup."
    (when my/user-mail-address-backup
       (setq user-mail-address my/user-mail-address-backup))))
#+end_src

*** Miscellaneous

Don't prompt me upon quitting ~mu4e~.
#+begin_src emacs-lisp
(setq mu4e-confirm-quit nil)
#+end_src

** ~agda~ mode

:TODO: Check for cleanup of Agda settings.

Agda comes with a tool ~agda-mode~ which can be used to locate
the Elisp files for the ~agda-mode~. It's recommended we
execute ~agda-mode locate~ when starting Emacs,
and load the files it reports.
#+begin_src emacs-lisp
(load-file (let ((coding-system-for-read 'utf-8))
               (shell-command-to-string "agda-mode locate")))
#+end_src

These packages are installed when setting up Agda,
so I simply ~require~ them.
They would be loaded when starting Agda mode,
but I need to load them now
- because I use ~agda2-info-buffer~ to open that buffer on startup,
- because I use ~agda-input~ everywhere, and
#+begin_src emacs-lisp
(require 'agda2-mode)
(require 'agda-input)
#+end_src

*** Command line arguments

Dr. Wolfram Kahl has recommended customising the following settings.
Note that my machine is a virtual machine running on a Chromebook
which, at time of writing (January 2020) has around ~6G~ (out of
the system's total ~8G~) available to it.

That said, my machine is routinely lagging quite badly,
and so I am trying to find the “sweet spot”.
#+begin_src emacs-lisp
(setq agda2-program-args '("+RTS" "-M3.0G" "-H0.6G" "-A128M" "-RTS"))
#+end_src

These arguments specify
| ~+RTS~, ~-RTS~ | Flags between these are arguments to the ~ghc~ runtime |
| ~-M[size]~   | Maximum heap size                                    |
| ~-H[size]~   | Suggested heap size                                  |
| ~-A[size]~   | Allocation area size used by the garbage collector   |

Full documentation for the ~ghc~ runtime argumentscan be found [[https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/runtime-control.html][here]].

Additional arguments that may be useful include
| ~-S[file]~ | Produces information about “each and every garbage collection” |
|          | - Outputs to ~stderr~ by default                               |

*** Alternative problem highlighting

I find the background colouring used by Agda for reporting
errors/warnings makes the underlying code too difficult
to read, especially in dark themes.

So I modify the faces Agda defines.
#+begin_src emacs-lisp
(require 'agda2-highlight)
#+end_src

First, we change all uses of background colouring to coloured boxes
instead.
#+begin_src emacs-lisp
;; Change backgrounds to boxes.
(cl-loop for (_ . face) in agda2-highlight-faces
      do (if (string-prefix-p "agda2-" (symbol-name face)) ;; Some non-Agda faces are in the list; don't change them
             (unless (equal face 'agda2-highlight-incomplete-pattern-face) ;; Workaround; this face is not defined in recent versions?
             (set-face-attribute face nil
               :box (face-attribute face :background)
               :background 'unspecified))))
#+end_src

These can also be intrusive in some cases; specifically, for
warnings about pattern matching. So I modify them specifically.
#+begin_src emacs-lisp
;; Coverage warnings highlight the whole function;
;; change the box to an underline to be less intrusive.
(set-face-attribute 'agda2-highlight-coverage-problem-face nil
  :underline (face-attribute 'agda2-highlight-coverage-problem-face :box)
  :box 'unspecified)

;; Deadcode warnings highlight the whole line;
;; change the box to a strikethrough to be less intrusive,
;; as well as thematically appropriate.
(set-face-attribute 'agda2-highlight-deadcode-face nil
  :strike-through (face-attribute 'agda2-highlight-deadcode-face :box)
  :box 'unspecified)

;; Non-definitional pattern matching may be ignored;
;; remove the colouring and just italicise it to be less intrusive.
(set-face-attribute 'agda2-highlight-catchall-clause-face nil
  :box 'unspecified
  :slant 'italic)
#+end_src

This code can be used to test out many of the redefined faces.
#+begin_src agda2
module HighlightTesting where
  open import Data.Nat using (ℕ ; zero ; suc)

  -- Coverage problem, non-definitional pattern matching, dead code.
  bad-pattern-matching : ℕ → ℕ
--bad-pattern-matching suc n   Missing case; other lines marked with coverage problem face
  bad-pattern-matching 0 = 0
  bad-pattern-matching (suc (suc 0)) = 0
  bad-pattern-matching (suc (suc n)) = 0 -- Non-definitional case (maybe use CATCHALL pragma?).
  bad-pattern-matching 0 = 0 -- Dead code.

  -- Non-terminating
  ∞? : ℕ
  ∞? = suc ∞?

  -- Unsolved meta warnings
  fail-to-solve-meta : ℕ
  fail-to-solve-meta = has-a-meta
    where
      has-a-meta : {n : ℕ} → ℕ
      has-a-meta = 0

  -- Shadowing in telescope
  shadowing-variable : (x : ℕ) → (x : ℕ) → ℕ
  shadowing-variable x y = x

  -- Missing function definition
  has-no-definition : Set

  data unpositive-type : Set where
    bad : (unpositive-type → ℕ) → unpositive-type
#+end_src

*** Add unicode characters to Agda's translations

**** Punctuation and parentheses

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '(";;" "﹔"))
(add-to-list 'agda-input-user-translations '(";;" "⨾"))
(add-to-list 'agda-input-user-translations '("|" "❙"))
(add-to-list 'agda-input-user-translations '("st" "•"))
(add-to-list 'agda-input-user-translations '("{" "｛"))
(add-to-list 'agda-input-user-translations '("}" "｝"))
(add-to-list 'agda-input-user-translations '("{" "⁅"))
(add-to-list 'agda-input-user-translations '("}" "⁆"))
(add-to-list 'agda-input-user-translations '("..." "…"))
#+end_src

**** Arrows

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("pto" "⇀"))
(add-to-list 'agda-input-user-translations '("into" "↪"))
(add-to-list 'agda-input-user-translations '("onto" "↠"))
(add-to-list 'agda-input-user-translations '("conv" "↓"))
(add-to-list 'agda-input-user-translations '("=v" "⇓"))
(add-to-list 'agda-input-user-translations '("eval" "⇓"))
#+end_src

**** Correct mistakes on subscripts/superscripts

I often accidentally hold the shift key for too long when entering
subscripts and superscripts; these translations account for that.

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("^!" "¹"))
(add-to-list 'agda-input-user-translations '("^@" "²"))
(add-to-list 'agda-input-user-translations '("^#" "³"))
(add-to-list 'agda-input-user-translations '("^$" "⁴"))
(add-to-list 'agda-input-user-translations '("^%" "⁵"))
(add-to-list 'agda-input-user-translations '("^^" "⁶"))
(add-to-list 'agda-input-user-translations '("^&" "⁷"))
(add-to-list 'agda-input-user-translations '("^*" "⁸"))
(add-to-list 'agda-input-user-translations '("^(" "⁹"))
(add-to-list 'agda-input-user-translations '("^)" "⁰"))
(add-to-list 'agda-input-user-translations '("_!" "₁"))
(add-to-list 'agda-input-user-translations '("_@" "₂"))
(add-to-list 'agda-input-user-translations '("_#" "₃"))
(add-to-list 'agda-input-user-translations '("_$" "₄"))
(add-to-list 'agda-input-user-translations '("_%" "₅"))
(add-to-list 'agda-input-user-translations '("_^" "₆"))
(add-to-list 'agda-input-user-translations '("_&" "₇"))
(add-to-list 'agda-input-user-translations '("_*" "₈"))
(add-to-list 'agda-input-user-translations '("_(" "₉"))
(add-to-list 'agda-input-user-translations '("_)" "₀"))
#+end_src

**** Emoticons

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '(":)" "😀"))
(add-to-list 'agda-input-user-translations '("grin" "😀"))
(add-to-list 'agda-input-user-translations '("Grin" "😁"))
(add-to-list 'agda-input-user-translations '("meh" "😐"))
(add-to-list 'agda-input-user-translations '("sad" "🙁"))
(add-to-list 'agda-input-user-translations '("gah" "😵"))
(add-to-list 'agda-input-user-translations '("yes" "✔"))
(add-to-list 'agda-input-user-translations '("no" "❌"))
#+end_src

😀 😁 😐 🙁 😵

**** Better access to prime symbols

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("''" "″"))
(add-to-list 'agda-input-user-translations '("'''" "‴"))
(add-to-list 'agda-input-user-translations '("''''" "⁗"))
#+end_src

**** Small, halfwidth and fullwidth math symbols

These can be useful where use of the normal symbols
is restricted; for instance, in ~ditaa~ diagrams many
of them have special meaning.
#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("s*" "﹡"))
(add-to-list 'agda-input-user-translations '("s+" "﹢"))
(add-to-list 'agda-input-user-translations '("s-" "﹣"))
(add-to-list 'agda-input-user-translations '("s<" "﹤"))
(add-to-list 'agda-input-user-translations '("s>" "﹥"))
(add-to-list 'agda-input-user-translations '("s=" "﹦"))
(add-to-list 'agda-input-user-translations '("s\\" "﹨"))
(add-to-list 'agda-input-user-translations '("f+" "＋"))
(add-to-list 'agda-input-user-translations '("f<" "＜"))
(add-to-list 'agda-input-user-translations '("f=" "＝"))
(add-to-list 'agda-input-user-translations '("f>" "＞"))
(add-to-list 'agda-input-user-translations '("f\\" "＼"))
(add-to-list 'agda-input-user-translations '("f^" "＾"))
(add-to-list 'agda-input-user-translations '("f|" "｜"))
(add-to-list 'agda-input-user-translations '("f~" "～"))
(add-to-list 'agda-input-user-translations '("fnot" "￢"))
(add-to-list 'agda-input-user-translations '("h<-" "￩"))
(add-to-list 'agda-input-user-translations '("hu" "￪"))
(add-to-list 'agda-input-user-translations '("h->" "￫"))
(add-to-list 'agda-input-user-translations '("hd" "￬"))
#+end_src

**** Other

#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("op" "⊕"))
(add-to-list 'agda-input-user-translations '("^<" "﹤"))
(add-to-list 'agda-input-user-translations '("d<" "⪡"))
(add-to-list 'agda-input-user-translations '("powset" "℘"))
(add-to-list 'agda-input-user-translations '("X" "⨉"))
;; Lunate sigmas
(add-to-list 'agda-input-user-translations '("Ls" "ϲ"))
(add-to-list 'agda-input-user-translations '("LS" "Ϲ"))
#+end_src

This Yi script character for the syllable “git” I use
as a shorthand for “git” (the version control software)
in my tab names.
#+begin_src emacs-lisp
(add-to-list 'agda-input-user-translations '("git" "ꇚ"))
#+end_src

**** Activate the new additions

#+begin_src emacs-lisp
(agda-input-setup)
#+end_src

*** Activate Agda input mode in ~text~, ~prog~ and ~artist~ modes

Agda input mode makes it extremely easy to use unicode in documents,
something I strongly prefer to do.
When I can use symbols directly, instead of (for instance)
LaTeX commands, it makes my plaintext far more readable.

So, let's enable Agda input mode in most instances.
#+begin_src emacs-lisp
(add-hook 'text-mode-hook
       (lambda () (set-input-method "Agda")))
(add-hook 'prog-mode-hook
       (lambda () (set-input-method "Agda")))
(add-hook 'artist-mode-hook
       (lambda () (set-input-method "Agda")))
#+end_src

*** Org Agda mode

Org-Agda mode is a Polymode Musa and I created
for working on literate Agda documents written in Org mode.
[[https://github.com/alhassy/org-agda-mode]]

We need to install Polymode.
#+begin_src emacs-lisp
(use-package polymode)
#+end_src

#+begin_src emacs-lisp
(require 'org-agda-mode)
#+end_src

* Keybindings

I make use of ~general~ to organise keybindings.
#+begin_src emacs-lisp
(use-package general)
#+end_src

** ~general~ definers

You can use ~general-define-key~ directly to define shortcuts,
ideally using the keyword argument ~:prefix~ to avoid repeating
prefixes, but if you are (even only possibly)
using a prefix several times,
it's better to create a custom function to use instead of
~general-define-key~.

Setting ~:keymaps~ to ~'override~ ensures that no package will
override my shortcuts.

#+begin_src emacs-lisp
(general-create-definer general-main-define-key
  :prefix "C-c"
  :keymaps 'override)

(general-create-definer general-appearance-define-key
  :prefix "C-c a"
  :keymaps 'override)

(general-create-definer general-buffer-define-key
  :prefix "C-c b"
  :keymaps 'override)

(general-create-definer general-window-define-key
  :prefix "C-c w"
  :keymaps 'override)

(general-create-definer general-tab-define-key
  :prefix "C-c t"
  :keymaps 'override)

(general-create-definer general-dired-define-key
  :prefix "C-c d"
  :keymaps 'override)

(general-create-definer general-shell-define-key
  :prefix "C-c s"
  :keymaps 'override)

(general-create-definer general-other-package-define-key
  :prefix "C-c p"
  :keymaps 'override)
#+end_src

** Invoke processes

*** ~yankpad~

#+begin_src emacs-lisp
(general-main-define-key
  "f" 'yankpad-expand)

(general-other-package-define-key
  "y m" 'yankpad-map
  "y r" 'yankpad-reload)
#+end_src

*** ~dired~

**** Jumping to specific files

These are not properly ~dired~ shortcuts, but some files
I open often enough to want a direct shortcut.
#+begin_src emacs-lisp
(general-dired-define-key
  "s" '(:ignore t
        :which-key "scratch buffers")
  "sa" '((lambda () (interactive)
           (find-file "~/Dropbox/McMaster/Agda/agda-scratch.agda"))
         :which-key "agda scratch")
  "so" '((lambda () (interactive)
           (find-file "~/logs/scratch/org-scratch.org"))
         :which-key "org scratch")
  "e" '((lambda () (interactive)
           (find-file "~/dotfiles/emacs/emacs-init.org"))
         :which-key "emacs init"))
#+end_src

**** Jumping to directories

I use shortcuts to jump to frequently used directories in ~dired~
(from any buffer, not just while in ~dired~).

Some times it is convenient to use a different function to
invoke ~dired~; in particular, in the past,
I used ~dired-single~ with the invokation ~dired-single-magic-buffer~,
in order to avoid having multiple ~dired~ buffers created.
This turned out to be detrimental once I started keeping
multiple ~dired~ windows open in different tabs.
#+begin_src emacs-lisp
(defun my-dired-invocation (directory)
  "My custom dired invocation.
   It will use my special “magic buffer” for browsing."
  (dired directory))
#+end_src

#+begin_src emacs-lisp
  (general-dired-define-key
    "c" '((lambda () (interactive)
            (my-dired-invocation default-directory))
          :which-key "current")
    "/" '((lambda () (interactive)
            (my-dired-invocation "/"))
          :which-key "root")
    "h" '((lambda () (interactive)
            (my-dired-invocation "~"))
          :which-key "home")
    "~" '((lambda () (interactive)
            (my-dired-invocation "~"))
          :which-key "home")
    "d" '((lambda () (interactive)
            (my-dired-invocation "~/dotfiles/"))
          :which-key "dotfiles")
    "D" '((lambda () (interactive)
            (my-dired-invocation "~/Downloads/"))
          :which-key "downloads")
    "l" '((lambda () (interactive)
            (my-dired-invocation "~/log/"))
          :which-key "logs")
    "r" '((lambda () (interactive)
            (my-dired-invocation "~/reading/"))
          :which-key "reading")
    "p" '((lambda () (interactive)
            (my-dired-invocation "~/projects/"))
          :which-key "projects")
    "t" '((lambda () (interactive)
            (my-dired-invocation "~/teaching/"))
          :which-key "teaching")
    "T" '((lambda () (interactive)
            (my-dired-invocation "~/projects/agda-computability"))
          :which-key "thesis"))
#+end_src

*** ~eshell~

:TODO: This will not work if ~eshell~ instances are created without this shortcut. Instead I should count the number of shell buffers existing?
#+begin_src emacs-lisp
(general-shell-define-key
  "s" 'eshell)

(setq my/eshell-counter 0)
(general-shell-define-key
  "n" '((lambda () (interactive)
          (setq my/eshell-counter (+ 1 my/eshell-counter))
          (eshell my/eshell-counter))
        :which-key "new eshell"))
#+end_src

*** ~magit~

#+begin_src emacs-lisp
(general-main-define-key
  "g" 'magit-status)
#+end_src

*** ~mu4e~

#+begin_src emacs-lisp
(general-main-define-key
  "m" 'mu4e)
#+end_src

With insight on performing the buffer kill action
after the asynchronous
shell command finishes from [[https://emacs.stackexchange.com/questions/42172/run-elisp-when-async-shell-command-is-done][here]].
See the ~kill-buffer-on-process-finish~ definition earlier in this file.
#+begin_src emacs-lisp
(general-other-package-define-key
  "m" '((lambda () (interactive)
          (let* ((output-buffer-name "*mbsync all directories*")
                 (output-buffer (generate-new-buffer output-buffer-name))
                 (process (progn
                         (async-shell-command "mbsync gmail-quick; echo Finished" output-buffer)
                         (get-buffer-process output-buffer))))
              (if (process-live-p process)
                  (set-process-sentinel process #'kill-buffer-on-process-finish) 
                (message "mbsync all directories is not running, but I expected it to be!"))))
        :which-key "mbsync all directories"))
#+end_src

*** ~list-processes~

#+begin_src emacs-lisp
(general-other-package-define-key
  "p" 'list-processes)
#+end_src

** Buffer 

#+begin_src emacs-lisp
(general-buffer-define-key
  "r" '((lambda () (interactive) (revert-buffer () t ()))
        :which-key "revert buffer")

  "u" '(:ignore t
        :which-key "undo actions")
  "u p" '((lambda () (interactive) (undo-propose))
          :which-key "undo-propose")
  "u t" '((lambda () (interactive) (undo-tree-visualize))
          :which-key "undo-tree")

  "t" '((lambda () (interactive) (beginning-of-buffer))
        :which-key "buffer top")
  "b" '((lambda () (interactive) (end-of-buffer))
        :which-key "buffer bottom"))
#+end_src

** Appearance

#+begin_src emacs-lisp
(general-appearance-define-key
  "t"   '(:ignore t
          :which-key "themes")
  "t t" '((lambda () (interactive) (toggle-my-themes))
          :which-key "toggle theme")
  "t c" '((lambda () (interactive) (disable-all-custom-themes))
          :which-key "clear theme"))
#+end_src

#+begin_src emacs-lisp
(general-appearance-define-key
  "o"   '(:ignore t
          :which-key "org cosmetics")
  "o i"   '(:ignore t
            :which-key "org indent")
  "o i y" '((lambda () (interactive) (org-indent-mode 1))
            :which-key "org indent yes")
  "o i n" '((lambda () (interactive) (org-indent-mode 0))
            :which-key "org indent no"))
#+end_src

These are cosmetics relating to lines in the current buffer.
#+begin_src emacs-lisp
(general-appearance-define-key
  "l"     '(:ignore t
            :which-key "line cosmetics")
  "l n"   '(:ignore t
            :which-key "line numbers")
  "l n y" '((lambda () (interactive) (display-line-numbers-mode 1))
            :which-key "line numbers - yes")
  "l n n" '((lambda () (interactive) (display-line-numbers-mode 0))
            :which-key "line numbers - no")
  "l w"   '(:ignore t
            :which-key "line wrap")
  "l w y" '((lambda () (interactive) (visual-line-mode 1))
            :which-key "yes line wrap")
  "l w n" '((lambda () (interactive) (visual-line-mode 0))
            :which-key "no line wrap"))
#+end_src

Sometimes I need to toggle fontlocking.
#+begin_src emacs-lisp
(general-appearance-define-key
  "f"     '(:ignore t
            :which-key "font lock")
  "f y"   '((lambda () (interactive)
              (font-lock-mode t))
            :which-key "yes font lock")
  "f n"   '((lambda () (interactive)
              (font-lock-mode 0))
            :which-key "no font lock"))
#+end_src

** Window management

#+begin_src emacs-lisp
(general-window-define-key
  "<right>" '((lambda () (interactive) (windmove-right))
              :which-key "move focus right")
  "<left>"  '((lambda () (interactive) (windmove-left))
              :which-key "move focus left")
  "<up>"    '((lambda () (interactive) (windmove-up))
              :which-key "move focus up")
  "<down>"  '((lambda () (interactive) (windmove-down))
              :which-key "move focus down")

  "f"  '((lambda () (interactive) (other-frame 1))
              :which-key "other frame")
  
  "["  'winner-undo
  "]"  'winner-redo

  "-"     '((lambda () (interactive) (shrink-window 5))
            :which-key "shrink window")
  "="     '((lambda () (interactive) (enlarge-window 5))
            :which-key "enlarge window")
  "_"     '((lambda () (interactive) (shrink-window 999))
            :which-key "minimise window")
  "+"     '((lambda () (interactive) (enlarge-window 999))
            :which-key "maximise  window"))
#+end_src

** Tab management

#+begin_src emacs-lisp
  (general-tab-define-key
    "r" 'tab-rename
    "k" 'tab-close
    "n" 'tab-new

    "<right>" 'tab-next
    "<left>"  'tab-previous
    "<down>"  'tab-recent
    "<up>"    'tab-undo
    "S-<right>" '((lambda () (interactive) (tab-move 1))
                :which-key "move tab to left")
    "S-<left>"  '((lambda () (interactive) (tab-move -1))
                :which-key "move tab to right")

    "1" (lambda () (interactive) (tab-select 1))
    "2" (lambda () (interactive) (tab-select 2))
    "3" (lambda () (interactive) (tab-select 3))
    "4" (lambda () (interactive) (tab-select 4))
    "5" (lambda () (interactive) (tab-select 5))
    "6" (lambda () (interactive) (tab-select 6))
    "7" (lambda () (interactive) (tab-select 7))
    "8" (lambda () (interactive) (tab-select 8))
    "9" (lambda () (interactive) (tab-select 9))
    "0" (lambda () (interactive) (tab-select 10))
    "-" (lambda () (interactive) (tab-select 11))
    "=" (lambda () (interactive) (tab-select 12)))
#+end_src

** Counsel

#+begin_src emacs-lisp
(general-main-define-key
  "y" 'counsel-yank-pop)
#+end_src

** Company

#+begin_src emacs-lisp
(general-main-define-key
  "c" 'company-manual-begin)
#+end_src

** Other

#+begin_src emacs-lisp
(general-other-package-define-key
  "j" 'dad-joke)
#+end_src

* Intermediate cosmetics

** Whitespace display

*** Tabs

I usually use spaces rather than tabs,
so I use ~whitespace-mode~ to alert me to the presence of tabs.
#+begin_src emacs-lisp
(global-whitespace-mode t)
#+end_src

Setting ~whitespace-style~ to ~tab-mark~ visualises tabs
by changing the display table to show a character at the
location of the tab.
#+begin_src emacs-lisp
(setq whitespace-style '(tab-mark))
#+end_src

Also, make tabs less wide. I dislike them taking up too much of the screen.
#+begin_src emacs-lisp
(setq-default tab-width 2)
#+end_src

*** Non-breaking spaces

Since I use unicode regularly, I do use non-breaking spaces
occasionally, especially for intraperiodic spaces, e.g.,
following ~Dr.~ or ~Mrs.~.
I do want to be aware of those spaces; thankfully there is
a face for that.
#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(nobreak-space ((t (:underline t)))))
#+end_src

*** Deprecated whitespace highlighting

I previously used ~whitespace-style~ to highlight
trailing whitespace; however, I find this feature intrusive,
so I avoid it.

If it is wanted later, then I should add to the list
#+begin_example emacs-lisp
(face trailing)
#+end_example
We need to add ~face~ to the list, to enable using faces
to highlight whitespace.

Note there is no way to visualise spaces only at the end of lines;
The visualisation is done by changing the display table,
and there is no ability to do so only in particular places.
Otherwise I would use that rather than highlighting.

** Rainbow delimiters

Above, I have settings for highlighting the delimiter
matching the one under the cursor.

The package ~rainbow-delimiters~ goes ones step further than
highlighting the delimiter matching the one under cursor;
it makes the matching of all delimiters
obvious by using various colours.
Each level of nesting uses a different colour.
#+begin_src emacs-lisp
(use-package rainbow-delimiters)
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
(add-hook 'text-mode-hook #'rainbow-delimiters-mode)
#+end_src

One potential downside of ~rainbow-delimiters~ is that when
delimiter matching fails for reasons out of our control,
it can make the appearance of delimiters very poor in that buffer.

# Commented opening paren to match unmatched closing one in example below (
For instance, if we write a list using a parenthese after each label,
1) such as here,
those parentheses will be unmatched, and will be highlighted in red.

Worse, in some modes, it is not clear which delimiters
should be matched and which not.
In particular, delimiters which occur inside strings
in code should not be considered as proper delimiters,
and programming modes usually set up this behaviour.
But Org mode source blocks for those languages do not inherit
that behaviour, so such delimiters are not given any special status
and will be highlighted.

If we are working on another's Org code, there is little we can do
to alleviate this.
In my own Org code, I tend to insert comments to match the delimiters,
or avoid cases where this can occur (such as using periods after
the labels in lists.)

For an example of this, see my settings for the Org emphasis
regular expressions, which require some commented out
delimiters to avoid breaking all delimiter matching
later in this file.

** Tab-bar

#+begin_src emacs-lisp
(tab-bar-mode)
#+end_src

The default colouring is a basic Emacs grey;
let's spruce it up.
#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 '(tab-bar ((t
     (:foreground "black"
      :background "DarkSlateGray4"))))
  '(tab-bar-tab ((t
     (:foreground "black"
      :background "DarkSlateGray3"
      :box (:line-width 1 :style released-button)))))
  '(tab-bar-tab-inactive ((t
     (:foreground "black"
      :background "DarkSlateGray4"
      :box (:line-width 1 :style released-button))))))
#+end_src

Do show numbers on tabs, for the purpose of quickly changing.
#+begin_src emacs-lisp
(setq tab-bar-tab-hints 't)
#+end_src

Remove the close buttons; hitting them by mistake is annoying,
and I can close tabs by other commands easily enough.
#+begin_src emacs-lisp
(setq tab-bar-close-button-show nil)
#+end_src

** A more noticable divider between windows

One problem with a fill column ruler is that it can seem like
it is the divider between windows.

For that reason, I like to have a more noticable divider
between windows. ~window-divider-mode~ provides this.
#+begin_src emacs-lisp
(window-divider-mode)
#+end_src

** Dim buffers when not in use

The package ~dimmer~ will dim inactive windows to emphasise which
window has focus.
See its [[https://github.com/gonewest818/dimmer.el][Github page]].
#+begin_src emacs-lisp
(use-package dimmer)
#+end_src

Turn ~dimmer-mode~ on when Emacs starts.
#+begin_src emacs-lisp
(dimmer-mode)
#+end_src

Don't dim ~which-key~ and ~helm~ buffers.
#+begin_src emacs-lisp
(dimmer-configure-which-key)
(dimmer-configure-helm)
#+end_src

We can adjust the ~:foreground~ colours, the ~:background~ colours,
or ~:both~. With a dark theme, adjusting the background causes
the background to become lighter in inactive buffers,
which “looks wrong” (makes them looked like they have focus).
So I set this to just ~:foreground~ (which is the default anyway).
#+begin_src emacs-lisp
(setq dimmer-adjustment-mode :foreground)
#+end_src

I find the default dimming of ~20%~ to be too faint;
it is noticeable when changing windows, but it does not
remain noticeable enough later (e.g. when I look away from Emacs
then look back). Increasing that to ~30%~ seems to be sufficient,
while maintaing the readability of unfocussed buffers.
#+begin_src emacs-lisp
(setq dimmer-fraction 0.3)
#+end_src

Note that by default, all windows will be dimmer when Emacs
notices that it does not have focus in the windowing system.
I like this behaviour; it could be changed by changing
the variable ~dimmer-watch-frame-focus-events~.

** Kill the open init buffer and reopen it

To ensure all these cosmetic changes are picked up,
kill my init buffer that we opened earlier and reopen it.
#+begin_src emacs-lisp
(kill-buffer "emacs-init.org")
(find-file my/emacs-init-file)
#+end_src

* Intermediate modes and intermediate mode settings

** Org mode

The remaining Org mode settings, including export settings, are found here.

** Org mode cosmetics

**** Indent text based on heading by default

Although it wastes some space, it's generally easier to read
Org files if the contents of a heading are indented
based on the nesting of the heading.
#+begin_src emacs-lisp
(setq org-startup-indented t)
#+end_src

This can be overrode for particular files
by using the ~startup~ setting ~noindent~.
(I.e., put ~#+startup: noindent~ in the file.)

**** Hide emphasis markers by default

Emphasis markers, the markup syntax that
makes particular portions of the text bold, italicized, etc.,
do not generally need to be seen when deiting.
#+begin_src emacs-lisp
(setq org-hide-emphasis-markers t)
#+end_src

It is convenient to show the emphasis markers around point.
Otherwise it becomes tedious to edit emphasised text.

There have been a couple Reddit posts seeking to solve this problem.
First, [[https://www.reddit.com/r/orgmode/comments/43uuck/][this code]] which doesn't work for all emphasis markers.
#+begin_example emacs-lisp
(defun org-show-emphasis-markers-at-point ()
  (save-match-data
    (if (and (org-in-regexp org-emph-re 2)
             (>= (point) (match-beginning 3))
             (<= (point) (match-end 4))
             (member (match-string 3) (mapcar 'car org-emphasis-alist)))
        (with-silent-modifications
         (remove-text-properties
          (match-beginning 3) (match-beginning 5)
           '(invisible org-link)))
      (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5))))))
#+end_example

Then, [[https://www.reddit.com/r/orgmode/comments/dj5u1y][this more recent code]]
which adds more checks.
However, it seems to lag input a bit?
#+begin_example emacs-lisp
(defun sbr-org-toggle-emphasis-markers-at-point ()
  (interactive)
  (save-match-data
    (when (or (org-in-regexp org-emph-re 2)
              (org-in-regexp org-verbatim-re 2))
      (if (and (>= (point) (match-beginning 3))
               (<= (point) (match-end 4))
               (member (match-string 3) (mapcar 'car org-emphasis-alist))
               (get-text-property (match-beginning 3) 'invisible))
          (with-silent-modifications
            (remove-text-properties
             (match-beginning 3) (match-beginning 5)
             '(invisible org-link)))
        (apply 'font-lock-flush (list (match-beginning 3) (match-beginning 5)))))))
#+end_example

This is my attempt, combining the two to some extent.
:TODO: this doesn't always hide the characters after point leaves
#+begin_src emacs-lisp
(defun org-toggle-emphasis-markers-at-point ()
  (save-match-data
    (when (or (org-in-regexp org-emph-re 2)
              (org-in-regexp org-verbatim-re 2)
              (org-in-regexp org-link-any-re 2))
      (if (and (>= (point) (match-beginning 3))
               (<= (point) (match-end 4))
               (member (match-string 3) (mapcar 'car org-emphasis-alist)))
               ;; invisible check?
          (with-silent-modifications
            (remove-text-properties
             (match-beginning 3) (match-beginning 5)
             '(invisible org-link)))
        (apply 'font-lock-flush
          (list (match-beginning 3) (match-beginning 5)))))))
#+end_src

We run the above function after each command in an Org mode buffer.
:TODO: improve this functionality before use.
#+begin_src emacs-lisp
;(add-hook 'org-mode-hook
;  (lambda ()
;    (add-hook 'post-command-hook
;      'org-toggle-emphasis-markers-at-point nil t)))
#+end_src

**** Emphasis marker regexps

We can change the behaviour of Org emphasis markers
in terms of what characters are allowed to occur around
and between them; see 
[[https://emacs.stackexchange.com/questions/41111/][this stack exchange post]]
for a sample setup, and
[[https://emacs.stackexchange.com/questions/13820][this other post]]
which is linked to from the first and which has more details.

Note that these settings are somewhat complicated
by the fact that they are used to construct regular expressions;
I lost a great amount of time to misplaced brackets and braces,
which made Org very confused about what I wanted,
since they were misinterpreted as regular expression syntax.
See my
[[https://stackoverflow.com/q/63805679/2041536][StackOverflow question]] on this.

Everything here must be set when Org is loaded.
#+begin_src emacs-lisp
(with-eval-after-load 'org
#+end_src

Only these characters are allowed to immediately precede
an emphasis character (left outer boundary characters).
Note that, as I am including a dash, it must be the first or final character,
and if including a closing bracket, it must be the first character.
See [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Regexp-Special.html#Regexp-Special][Special Characters in Regular Expression]].
#+begin_src emacs-lisp
  (setcar org-emphasis-regexp-components
    (concat
      ;; All whitespace characters.
      "[:space:]"
      (string
        ;; Opening delimiters; the comments prevent check-parens from getting mad 😀.
        ?( ;;)
        ?{ ;;}
        ?“ ;;”
        ?[ ;]
        ;; Dashes
        ?— ?– ?-))) ;; Do not move the dash. It will break the regexp.
#+end_src

Only these characters are allowed to immedately follow
an emphasis character (right outer boundary characters).
#+begin_src emacs-lisp
  (setcar (nthcdr 1 org-emphasis-regexp-components)
    (concat
      (string ;[
         ?]) ;; Do not move the bracket. It will break the regexp.
      ;; All whitespace characters.
      "[:space:]"
      (string
        ;; Closing delimiters, with matching comments as above.
           ;;(
        ?) ;;{
        ?} ;;“
        ?”
        ;; Single quote
        ?'
        ;; Punctuation
        ?. ?? ?! ?, ?; ?:
        ;; Dashes
        ?– ?— ?-))) ;; Do not move the dash. It will break the regexp.
#+end_src

Any characters are allowed as inner boundary characters,
/except/ for those listed here.
#+begin_src emacs-lisp
  (setcar (nthcdr 2 org-emphasis-regexp-components)
    "[:space:]")
#+end_src

Any characters are allowed between the inner border characters.
(The regular expression ~.~ matches any character).
#+begin_src emacs-lisp
  (setcar (nthcdr 3 org-emphasis-regexp-components)
    ".")
#+end_src

Only one newline allowed, though.
#+begin_src emacs-lisp
  (setcar (nthcdr 4 org-emphasis-regexp-components) 1)
#+end_src

Now we update the setting.
#+begin_src emacs-lisp
  (org-set-emph-re
    'org-emphasis-regexp-components
    org-emphasis-regexp-components))
#+end_src
NOTE the extra closing parenthesis to end the ~with-eval-after-load~!

***** Test it out

Here are tests of all the ~pre~ and ~post~ values at time of writing.
#+begin_src org
 *test*
(*test*
)
[*test*
]
{*test*
}
“*test*
”
-*test*
–*test*
—*test*

*test* ;
(
*test*)
[
*test*]
{
*test*}
“
*test*”
*test*-
*test*–
*test*—
*test*.
*test*?
*test*!
*test*,
*test*;
*test*:
#+end_src

**** Highlight math mode blocks

Org mode supports some LaTeX content inline.
In particular, we can use math mode syntax ~$…$~ and
subscripts ~_{…}~ and superscripts ~^{…}~.
We should highlight this content to emphasis its presence.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(latex script entities))
#+end_src

:TODO: What does ~entities~ refer to here?

**** Pretty bullets

Replace the plain asterisk bullets preceding Org headings
with fancier characters; a collection is used, so that
headings at different levels have different bullets.
#+begin_src emacs-lisp
(use-package org-bullets
  :hook (org-mode . org-bullets-mode))
#+end_src

**** Replace the ellipsis ~...~

By default, folded portions of the document are
presented by an ellipsis, ~...~. Let's replace that.
#+begin_src emacs-lisp
(setq org-ellipsis " ⮷")
#+end_src

But I find the arrow I use is not particularly visible with my theme;
it gets set to a very faint colour.
So, I customise the ~org-ellipsis~ face so that it has
the same colour as the rest of the headline.
It has to be set after every theme change, or the setting will
be overwritten (probably the themes I use set it specifically?).
#+begin_src emacs-lisp
(add-hook 'after-load-theme-hook
  (lambda ()
    (set-face-attribute
      'org-ellipsis
      nil ;; all frames
      :foreground 'unspecified)))
#+end_src

**** Inline images

We can configure Org to automatically inline linked images
when opening documents.
#+begin_src emacs-lisp
(setq org-startup-with-inline-images t)
#+end_src

**** Tag position

By default (as of Org 9.1.9),
tags get shifted to the 77th column.
But this causes blank lines to be inserted
when working on narrower screens.
I bump it down a good bit,
to ensure tags stay away from the right side of the screen.
#+begin_src emacs-lisp
(setq org-tags-column 48)
#+end_src

**** Adjusting image display size

I like to use inline images in Org mode, but of course
I don't want large images to be shown at full size!
Better to err on the side of making images too small,
so set the width of all images to be just 100 pixels.
#+begin_src emacs-lisp
(setq org-image-actual-width 100)
#+end_src

**** Colour-coded ~src~ block backgrounds

The Modus themes allow for colour-coded
backgrounds of Org ~src~ blocks,
where the colour depends on the language.
Neat!

#+begin_src emacs-lisp
(use-package modus-themes)
(setq modus-themes-org-blocks 'rainbow)
#+end_src

This function will add some colour associations.
:TODO: use more varied colours. There are subtle and fringe variants of each.
#+begin_src emacs-lisp
(defun my/modus-add-org-src-block-faces ()
  (setq org-src-block-faces (append org-src-block-faces
         `(("text"       modus-theme-nuanced-red)
           ("emacs-lisp" modus-theme-nuanced-magenta)
           ("elisp"      modus-theme-nuanced-magenta)
           ("clojure"    modus-theme-nuanced-magenta)
           ("latex"      modus-theme-nuanced-yellow)
           ("ditaa"      modus-theme-nuanced-yellow)
           ("dot"        modus-theme-nuanced-yellow)
           ("haskell"    modus-theme-nuanced-blue)
           ("elm"        modus-theme-nuanced-blue)
           ("scala"      modus-theme-nuanced-blue)
           ("amm"        modus-theme-nuanced-blue)
           ("ruby"       modus-theme-nuanced-green)
           ("prolog"     modus-theme-nuanced-cyan)
           ("agda"       modus-theme-nuanced-cyan)))))
#+end_src

Run the function every time we change themes.
#+begin_src emacs-lisp
(add-hook 'after-load-theme-hook 'my/modus-add-org-src-block-faces)
#+end_src

Run it now to apply the change, since the theme is already set.
#+begin_src emacs-lisp
(my/modus-add-org-src-block-faces)
#+end_src

***** COMMENT Test it out

The built in examples at least use the theme's nuanced colours.
The below examples assume the Modus Vivendi theme.
The Operandi colours are sometimes different.

Nuanced magenta for Lisps.
#+begin_example emacs-lisp
(defun my/cool-message (arg) (message "hello world"))
#+end_example

Nuanced blue for C's and functional languages.
#+begin_example c
void mycoolmessage(int arg) {
  printf("hello world");
}
#+end_example

Nuanced green for shells and shell scripting languages.
#+begin_example shell
echo "hello world"
#+end_example

Nuanced yellow for HTML-likes.
#+begin_example html
<p>Hello World</p>
#+end_example

Nuanced cyan for JSON and other configuration types.
#+begin_example json
{
    "test": "HelloWorld"
}
#+end_example

Nuanced red for text.
#+begin_example text
Hello world.
#+end_example

** Org mode exportation settings

*** Export in the background

Using ~latex-mk~, the export process for LaTeX takes a bit of time.
Tying up emacs during that time is annoying, so set the
export to happen in the background.
This setting can be modified locally in the export dialog frame
if desired by adding ~C-a~ to the export key sequence..
#+begin_src emacs-lisp
;;(setq org-export-in-background t)
#+end_src

This works by spawning a new Emacs session in which the file is exported.
By default, that session would use this init file, but that's overkill
and wastes time; most of this init is not relevant for that session.
So, we'll set a different init file, constructed from the relevant
portions of this file.
#+begin_src emacs-lisp
(setq org-export-async-init-file
  "~/.emacs.d/org-async-init.el") 
#+end_src

Some default settings.
#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/org-async-init.el
;; Org export init, tangled from my Emacs init
(require 'package)
(setq package-enable-at-startup nil)
(package-initialize)

(require 'org)
(require 'ox)
(require 'ox-extra)

(setq org-export-async-debug t)
#+end_src

:TODO: There must be a better way to generate this file.
These settings are from this exporting section.
#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/org-async-init.el
<<export-ignore-headlines>>
<<export-ignore-sections>>
<<export-preserve-indentation>>
<<export-htmlize>>
<<export-preserve-org-links>>
<<export-latex-compiler>>
<<export-latex-process>>
<<export-latex-classes>>
<<export-latex-beamer-classes>>
<<export-latex-minted>>
<<export-latex-hyperref>>
<<export-reveal>>
<<export-reveal-theme>>
<<export-reveal-title>>
<<export-reveal-extra-css>>
<<export-pandoc>>
<<export-headline-ids>>
<<export-sub-superscripts>>
#+end_src

We also need code evaluation settings, as code blocks may need
to be evaluated for export.
#+begin_src emacs-lisp :noweb yes :tangle ~/.emacs.d/org-async-init.el
<<evaluate-no-confirm>>
<<evaluate-languages>>
<<evaluate-ditaa-path>>
<<evaluate-geiser-implementation>>
<<evaluate-fsharp>>
<<evaluate-oz>>
<<evaluate-racket>>
<<evaluate-shell-init>>
<<evaluate-plantuml-path>>
#+end_src

*** Ignoring content

**** Headings

Use the ~:ignore:~ tag on headlines to omit the headline when
exporting, but keep its contents.
#+Name: export-ignore-headlines
#+begin_src emacs-lisp
(ox-extras-activate '(ignore-headlines))
#+end_src

Alternatively, use the ~:noexport:~ tag to omit the headline
/and/ its contents.
#+Name: export-ignore-sections
#+begin_src emacs-lisp
;;;; noexport is in the list by default
;; (add-to-list 'org-export-exclude-tags "noexport")
#+end_src

**** Drawers

Ignore all drawers when exporting, by default.
#+begin_src agda2
(setq org-export-with-drawers nil)
#+end_src

*** Source code block indentation and colouring

I want to preserve my indentation for source code during export.
#+Name: export-preserve-indentation
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src

The ~htmlize~ package preserves source code colouring on export to html.
(And presumably does a lot more I am not fully aware of).
#+Name: export-htmlize
#+begin_src emacs-lisp
(use-package htmlize)
#+end_src

Now, since I work with a dark theme (at least most of the time),
the source code colouring ~htmlize~ uses might not show up well
on the typically white background in the exported HTML.
This code from [[https://emacs.stackexchange.com/a/3512/30156][StackExchange]]
removes that problem; use the current background colour when exporting!
#+begin_src emacs-lisp
(defun my-org-inline-css-hook (exporter)
  "Insert custom inline css"
  (when (eq exporter 'html)
    (let ((my-pre-bg (face-background 'default)))
      ;;(setq org-html-head-include-default-style nil)
      (setq org-html-head-extra
            (format "<style>pre.src{background:%s;color:white;} </style>" my-pre-bg)))))

(add-hook 'org-export-before-processing-hook 'my-org-inline-css-hook)
#+end_src

The above was modified to not explicitely disable the default styling
(don't need it in my case, but also don't need to disable it)
and to use ~head-extra~ instead of ~head~, as ~head~ is overwritten
by the themes I use.

Note, if I set ~HTML_HEAD_EXTRA~ in an Org file,
then the background colour setting will be lost!

:TODO: It would be nice to pick up the background colour for that particular language, rather than default; I like the differing colours the Modus theme gives me for source blocks.

*** Don't change ~.org~ links to ~.html~

By default
(see the [[https://orgmode.org/manual/Links-in-HTML-export.html][manual]])
when exporting to HTML, Org will change ~.org~ links to ~.html~.
I don't want this; for instance, when teaching a course,
I like to link to both a generated HTML file and
the original Org source version of notes
(on my generated course homepage).
#+Name: export-preserve-org-links
#+begin_src emacs-lisp
(setq org-html-link-org-files-as-html nil)
#+end_src

If I mean to link to the HTML file, I will do so explicitely.

*** Require ~{}~ to denote sub/superscripts

Sometimes I want to export the characters ~_~ or ~^~.
However, Org allows these to be used for LaTeX style sub/superscripts,
so a lone ~_~ will be exported (to LaTeX at least)
as ~\_{}~ (and similarly for a lone ~^~).

In order to avoid this, but still allow for LaTeX style sub/superscripts,
we can use a setting to /require/ that sub/superscripts be enclosed in brackets
(which is my preference in any case).
#+Name: export-sub-superscripts
#+begin_src emacs-lisp
(setq org-export-with-sub-superscripts '{})
#+end_src

*** LaTeX export settings

**** Default LaTeX compiler

I use a lot of unicode, and I find ~xelatex~ and ~lualatex~
handle that more easily than ~pdflatex~.

From my experience so far, they seem pretty interchangable
for my purposes, so the decision of which to use is arbitrary.

Based on [[https://tex.stackexchange.com/questions/36/differences-between-luatex-context-and-xetex][this discussion on Stack Exchange]], LuaTeX seems the more
“up and coming” engine. I've used it for quite a while now,
and have found no problems with it.
#+Name: export-latex-compiler
#+begin_src emacs-lisp
(setq org-latex-compiler "lualatex")
#+end_src

**** LaTeX compilation process

I use ~latexmk~ to automatically run as many passes as needed
to resolve references, etc.
#+Name: export-latex-process
#+begin_src emacs-lisp
(setq org-latex-pdf-process
      '("latexmk -%latex -shell-escape -f %f"))
#+end_src

The flags/format specifiers are
| ~%latex~        | stands in for the latex compiler (defaults to the setting above) |
| ~-f~            | force continued processing past errors                           |
| ~%f~            | stands in for the (relative) filename                            |
| ~-shell-escape~ | necessary to use ~minted~                                          |

**** Custom document classes

I want a ~report~ class that begins with ~chapter~'s, rather than
~part~'s.
#+Name: export-latex-classes
#+begin_src emacs-lisp
(add-to-list
  'org-latex-classes
    '("report-noparts"
      "\\documentclass{report}"
      ("\\chapter{%s}" . "\\chapter*{%s}")
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
      ("\\paragraph{%s}" . "\\paragraph*{%s}")
      ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
#+end_src

Sometimes, for creating slides, ~beamer~ is useful.
(Though I try to avoid it now; it feels low level to me).
#+Name: export-latex-beamer-classes
#+begin_src emacs-lisp
(add-to-list
  'org-latex-classes
    '("beamer"
      "\\documentclass[presentation]{beamer}"
      ("\\section{%s}" . "\\section*{%s}")
      ("\\subsection{%s}" . "\\subsection*{%s}")
      ("\\subsubsection{%s}" . "\\subsubsection*{%s}")))
#+end_src

**** Use ~minted~ for code blocks

First, make sure we load the ~minted~ package.
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist '("newfloat" "minted"))
#+end_src
The ~newfloat~ package can be used with ~minted~ with
a ~newfloat~ option to, for instance, support pagebreaks
in the float. See this StackExchange
[[https://tex.stackexchange.com/questions/254044/][post]]
if you want to set that up.

Now, we tell Org to use a ~minted~ environment,
rather than the default ~verbatim~, for code.
#+begin_src emacs-lisp
(setq org-latex-listings 'minted)
#+end_src

***** Default options for ~minted~

One reason to use ~minted~ or ~listings~ over the simple ~verbatim~ is
that it can put decent-looking linebreaks where necessary
to prevent code running out of the margins.
This is controlled by the ~breaklines~ argument.

Probably there are other options I should add as well.

#+begin_src emacs-lisp
(setq org-latex-minted-options
  '(("breaklines" "true")))
#+end_src

***** Don't box unicode characters

Since I primarily export Agda code, which is full of unicode characters,
and most ~minted~ styles enclose those characters in a red ~fbox~,
I use this hack to disable ~fbox~'s inside ~minted~ environments.
(setq 'org-latex-packages-alist ())

#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist
  "\\makeatletter
\\def\\dontdofcolorbox{\\renewcommand\\fcolorbox[4][]{##4}}
\\AtBeginEnvironment{minted}{\\dontdofcolorbox}
\\makeatother")
#+end_src

#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist '("" "etoolbox"))
#+end_src

***** Treat ~agda2~ source as ~Haskell~ for listings

Unfortunately, ~minted~ doesn't support Agda,
so we simply have Org tell it that it's Haskell code.
#+begin_src emacs-lisp
(add-to-list 'org-latex-minted-langs '(agda2 "Haskell"))
#+end_src

***** Alternative: use ~listings~ in place of ~minted~

As a step between using ~verbatim~ blocks and
using ~minted~ for source code,
we can use the ~listings~ package.

I found that ~listings~ caused odd typesetting of my Agda code;
code was out of order, particularly when using underscores,
and had oddly placed line breaks.
It may have been an issue with treating Agda code as Haskell;
I didn't diagnose much before switching to
using ~minted~ instead.

If the setup is desired, here is how to do it:
#+begin_example emacs-lisp
(setq org-latex-listings t) ;; As opposed to 'minted
(add-to-list 'org-latex-listings-langs '(agda2 "Haskell"))
#+end_example

**** ~hyperref~ setup

The ~LaTeX~ ~hyperref~ package gives us better links.
I don't care for varying link colours, so I set them all to
the common blue colour.
#+Name: export-latex-hyperref
#+begin_src emacs-lisp
(setq org-latex-hyperref-template
  "\\hypersetup{
   pdfauthor={%a},
   pdftitle={%t},
   pdfkeywords={%k},
   pdfsubject={%d},
   pdfcreator={%c},
   pdflang={%L},
   colorlinks,
   linkcolor=blue,
   citecolor=blue,
   urlcolor=blue
   }
"
)
#+end_src

**** More flexible tables

Adding the ~tabularx~ package as a dependency gives us
more flexible tables when we need them.
See [[https://orgmode.org/manual/Tables-in-LaTeX-export.html][the Org manual]]
for information on how to export tables as ~tabularx~ tables.
#+begin_src emacs-lisp
(add-to-list 'org-latex-packages-alist
  '("" "tabularx"))
#+end_src

**** Image handling

I prefer to be explicit about how images are handled during export.
So, I turn off some defaults of how they are handled in LaTeX.

In particular, the LaTeX export backend by default
wraps images in ~center~ blocks; but this breaks the ability
to include images in tables.
#+begin_src emacs-lisp
(setq org-latex-images-centered nil)
#+end_src

:TODO: Is this setting wise?
#+begin_src emacs-lisp
(setq org-latex-image-default-width nil)
#+end_src

*** HTML export settings

**** Change the “Created” postamble to “Last update”

By default, ~org-html-postamble~ is set to ~auto~.
We overwrite that to ~t~ so that the postamble is constructed
following the ~org-html-postamble-format~, which we set.
#+begin_src emacs-lisp
(setq org-html-postamble t)

(setq org-html-postamble-format
 '(("en"
    "<p class=\"author\">Author: %a</p>
     <p class=\"author\">Contact: %e</p>
     <p class=\"date\">Original date: %d</p>
     <p class=\"date\">Last updated: %C</p>
     <p class=\"creator\">Created using %c</p>
     <p class=\"validation\">%v</p>")))
#+end_src

**** Ensure useful HTML anchors

This code snippet is borrowed from Musa's
[[https://github.com/alhassy/emacs.d/#Ensuring-Useful-HTML-Anchors][init]].

#+begin_quote
Upon HTML export, each tree heading is assigned
an ID to be used for hyperlinks.
Default IDs are something like org1957a9d,
which does not endure the test of time:
Re-export will produce a different id.
Here's a rough snippet to generate IDs from headings,
by replacing spaces with hyphens, for headings without IDs.
#+end_quote

I have made several edits.
- Begin by deleting all custom IDs which have apparently
  been added by this process.
- At each step, get the list of custom IDs from earlier in the file;
  if the ID we intend to add at this step is in that list,
  add a counter to the end, incrementing it until the ID is unique.
- Do not assign the custom id if
  the heading is tagged with ~:noexport:~ or ~:ignore:~;
  there's no point to adding one if the heading is not included
  in the export.
#+Name: export-headline-ids
#+begin_src emacs-lisp
(defun my/ensure-headline-ids (&rest _)
  "Org trees without a :CUSTOM_ID: property have the property
   set to be their headline.

   Trees whose headline are tagged with :ignore:
   are not given an ID.

   Trees whose headline are tagged with :noexport:
   and any subtrees of those trees are not given an ID.

   A prefix is used to identify IDs which were set by this process,
   so they can be recreated in case their headline changes.
   A postfix counter is used to prevent the case where
   trees cannot be linked to because they happen to share
   their heading with earlier trees.
  "
  (interactive)
  (let ((generated-ids ())
        (prefix "org-anchor-"))
    (flet ((append-counter (x n) (concat x "^" (number-to-string n))))
      (org-map-entries
       (lambda ()
         (let* ((heading-components (org-heading-components))
                (headline (nth 4 heading-components))       
                (tags     (nth 5 heading-components)))
           (if (and tags (string-match-p (regexp-quote ":noexport:") tags))
             ;; This heading is tagged as noexport.
             ;; Set org-map-continue-from to next heading at this level.
             ;; (Just moving to the next heading would not suffice;
             ;;  children of this heading are also not exported.)
             (setq org-map-continue-from (progn (org-goto-sibling)
                                                (line-beginning-position)))
             ;; Otherwise, check if this heading is tagged as ignore.
             (unless (and tags (string-match-p (regexp-quote ":ignore:") tags))
               ;; Otherwise, we want to check this heading's custom ID.
               (let ((id (org-entry-get nil "CUSTOM_ID")))
                 ;; If `id` was not found, or if it seems to have been generated by this function,
                 ;; proceed to generate a new custom ID.
                 (unless (and id (not (string-prefix-p prefix id)))
                   ;; Create the id. Concatenate the prefix...
                   (let ((new-id (concat prefix
                                     ;; ...with this heading's headline
                                     ;; (note spaces are not allowed in links;
                                     ;; substitute dashes for any found.)
                                     (s-replace " " "-" headline))))
                          (push new-id generated-ids)
                     ;; Finally, add a counter of the number of
                     ;; previous occurrences of this id, to prevent repetition.
                     (let ((unique-id (append-counter
                                        new-id 
                                        (seq-count (lambda (x) (string-equal x new-id))
                                                   generated-ids))))
                       (org-entry-put nil "CUSTOM_ID" unique-id)))))))))))))

;; Whenever html & md export happens, ensure we have headline ids.
(advice-add 'org-html-export-to-html :before 'my/ensure-headline-ids)
(advice-add 'org-md-export-to-markdown :before 'my/ensure-headline-ids)
#+end_src

*** Additional export formats

**** ~org-reveal~

I make use of ~org-reveal~ to create ~reveal.js~ slide decks.
This is way easier than dealing with ~beamer~ in LaTeX,
and results in much more attractive and better organised slides.
#+Name: export-reveal
#+begin_src emacs-lisp
(use-package ox-reveal)
#+end_src

If we're somewhat lazy, we to could keep
a local copy of the ~reveal.js~ packages,
and then point to it with the ~org-reveal-root~ variable.
More proactively, we can include the repo as a subrepo
of whatever project we're working on.
:TODO: Add instructions on how to do that here.

***** Theme

~reveal.js~ comes with many themes; ~black~ is the current default
at time of writing this. I set it just to be sure it stays consistent.

#+Name: export-reveal-theme
#+begin_src emacs-lisp
(setq org-reveal-theme "black")
#+end_src

At the time of writing, the included themes are
- ~black~: Black background, white text, blue links
- ~white~: White background, black text, blue links
- ~league~: Gray background, white text, blue links
- ~beige~: Beige background, dark text, brown links
- ~sky~: Blue background, thin dark text, blue links
- ~night~: Black background, thick white text, orange links
- ~serif~: Cappuccino background, gray text, brown links
- ~simple~: White background, black text, blue links
- ~solarized~: Cream-colored background, dark green text, blue links
(list from the [[https://github.com/hakimel/reveal.js/#theming][~reveal.js~ github]]).

***** Title page

The default title slide includes title and date, with the formatting
#+begin_src html
<h1 class="title">%t</h1>
<p class="date">Created: %d/p>
#+end_src
where ~%t~ stands for the document title and ~%d~ stands for the date.

I prefer a slightly smaller title, and additionally include
- the author name (~%s~) and
- the author email (~%a~).
#+Name: export-reveal-title
#+begin_src emacs-lisp
(setq org-reveal-title-slide
  "<h2 class=\"title\">%t</h2>
   <h3>%s</h3>
   <h4>%a</h4>
   <h5>%d</h5>")
#+end_src

**** ~ox-pandoc~

~ox-pandoc~ is “another exporter that translates Org-mode file to various other
formats via Pandoc”.

I don't make much use of it, but it more flexible, and so has
lots of options which make be useful in the future.

#+Name: export-pandoc
#+begin_src emacs-lisp
(use-package ox-pandoc)
#+end_src

*** Export markdown blocks as HTML

If we are given some markdown we wish to place into an Org file,
we can of course convert it to Org and place it appropriately.

If we're only interested in exporting to HTML, though,
we can more easily just put the markdown into a ~markdown~ ~src~ block,
and it can automatically be evaluated into HTML.

Note the result will not be visible in PDF exports!

For the basic process,
see https://christiantietze.de/posts/2020/10/org-babel-markdown-to-html/

First, we need Org babel functions for markdown;
apparently, this ten-year old (at time of writing) code
—https://github.com/tnoda/ob-markdown/blob/master/ob-markdown.el—
that does not seem to be in a package repository is
the best candidate.
#+begin_src emacs-lisp
(require 'ob-markdown)
#+end_src

Now we instruct Org mode to, by default,
wrap the results of evaluating ~markdown~ blocks in ~example html~ blocks,
and then export those results.
Again, note that nothing will show up in LaTeX exports!
#+begin_src emacs-lisp
(add-to-list 'org-babel-default-header-args:markdown
             '(:results . "output verbatim html"))
(add-to-list 'org-babel-default-header-args:markdown
             '(:exports . "results"))
#+end_src

** A completion framework; Ivy, Counsel and Swiper

:TODO: Better documentation here.

**** Ivy

#+begin_src emacs-lisp
(use-package ivy
  :config
  (ivy-mode 1)
#+end_src

Add recent files and bookmarks to ~ivy-switch-buffer~.
#+begin_src emacs-lisp
  (setq ivy-use-virtual-buffers t)
#+end_src

Display both the index and the count in the current candidate count.
#+begin_src emacs-lisp
  (setq ivy-count-format "(%d/%d) ")
#+end_src

Enable minibuffer commands in the minibuffer.
#+begin_src emacs-lisp
  (setq enable-recursive-minibuffers t)
#+end_src

# End the settings
#+begin_src emacs-lisp
)
#+end_src

**** Swiper

#+begin_src emacs-lisp
(use-package swiper
  :config
  ;; (global-set-key "\C-r" 'swiper)
  (global-set-key (kbd "C-s") 'swiper))
#+end_src

**** Counsel

:TODO: Move keybindings to General settings.
#+begin_src emacs-lisp
(use-package counsel
 :config
  (global-set-key (kbd "M-x") 'counsel-M-x)
  (global-set-key (kbd "C-x C-f") 'counsel-find-file))
#+end_src

** COMpleting ANYthing; Company

:TODO: Review these settings, and consider reformatting to avoid open parenthese across codeblocks.

Install ~company~ and set it to be used everywhere.
#+begin_src emacs-lisp
(use-package company
  :diminish
  :config
  (global-company-mode 1)
  (setq
#+end_src

I do find it convenient to require few characters before
getting autocomplete suggestions, but on my Chromebook
that slows things down far too much.
Let's require 4 characters before suggestions are provided.
#+begin_src emacs-lisp
   company-minimum-prefix-length 4
#+end_src

Search buffers using the same major mode for completion candidates.
Setting ~all~ instead would search all buffers.
#+begin_src emacs-lisp
   company-dabbrev-other-buffers t
   company-dabbrev-code-other-buffers t
#+end_src

Sort candidates by importance, then case, then in-buffer frequency.
#+begin_src emacs-lisp
   company-transformers '(company-sort-by-backend-importance
                          company-sort-prefer-same-case-prefix
                          company-sort-by-occurrence)
#+end_src

Align any annotations to completions to the right.
#+begin_src emacs-lisp
   company-tooltip-align-annotations t
#+end_src

Annotate the completions with numbers.
We can select an annotation with ~M-num~ instead
of navigating to it.
#+begin_src emacs-lisp
   company-show-numbers t
#+end_src

Show up to ten candidates in a tooltip.
When we get to the bottom of the list, wrap.
#+begin_src emacs-lisp
   company-tooltip-limit 10

   company-selection-wrap-around t
#+end_src

Don't downcase by default,
but if I choose a completion with different casing
than my prefix, change the prefix casing.
#+begin_src emacs-lisp
   company-dabbrev-downcase nil
   company-dabbrev-ignore-case nil
#+end_src

Pause very briefly before offering completion.
This way if I am typing quickly it does not try to interrupt.
#+begin_src emacs-lisp
   company-idle-delay 0.2)
#+end_src

Rebind the controls for completion.
I find using ~return~ distruptive, as often I mean to insert a newline
instead of complete a suggestion.
Use ~tab~ instead.
Also, if documentation is available, ~C-d~ accesses it
in a new temporary buffer.
#+begin_src emacs-lisp
  :bind (:map company-active-map
              ;; Don't complete on return.
              ("<return>" . nil) ("RET" . nil)
              ;; Use tab instead.
              ("<tab>" . company-complete-selection)
              ("C-d" . company-show-doc-buffer))) 
#+end_src

Pop up a tooltip when I hover on a completion that has documentation.
#+begin_src emacs-lisp
(use-package company-quickhelp
 :config
   (setq company-quickhelp-delay 0.1)
   (company-quickhelp-mode))
#+end_src

Add emoji support. For instance, ~:smile:~ completes to 😄.
#+begin_src emacs-lisp
(use-package company-emoji
  :config (add-to-list 'company-backends 'company-emoji))
#+end_src

** Snippets

I use ~yasnippets~ for text expansion, and ~yankpad~ to organise my
snippets.

For inserting snippets, we require string manipulation functions
from the ~subr-x~ package (built-in).
#+begin_src emacs-lisp
(require 'subr-x)
#+end_src

#+begin_src emacs-lisp
(use-package yasnippet)
(yas-global-mode t)

(use-package yankpad)
(setq yankpad-file "~/dotfiles/emacs/yankpad.org")
#+end_src

Ignore major mode, always use defaults.
Yankpad will freeze if no org heading has the name of the given category.
#+begin_src emacs-lisp
(setq yankpad-category "Default")
#+end_src

~yas-wrap-around-region~ controls what is inserted for a snippet's
~$0~ field. A non-nil, non-character setting has it insert the
current region's contents (i.e. if we highlight a region and
invoke a snippet, the region will be wrapped).
#+begin_src emacs-lisp
(setq yas-wrap-around-region t)
#+end_src

~yas-indent-line~ controls how inserted snippets are inserted.
~fixed~ indicates the snippet should be indented to the column at point.
~auto~ instead causes each line to be indented using ~indent-according-to-mode~.
I set it to fixed because this is usually what I want; I know best, not the mode.
#+begin_src emacs-lisp
(setq yas-indent-line 'fixed)
#+end_src

*** Interacting with Company

Taken without additional commentary for now from Musa's init.
#+begin_src emacs-lisp
;; Add yasnippet support for all company backends
;;
(cl-defun my/company-backend-with-yankpad (backend)
  "There can only be one main completition backend, so let's
   enable yasnippet/yankpad as a secondary for all completion
   backends.

   Src: https://emacs.stackexchange.com/a/10520/10352"

  (if (and (listp backend) (member 'company-yankpad backend))
      backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yankpad))))

;; Set company-backend as a secondary completion backend to all existing backends.
(setq company-backends (mapcar #'my/company-backend-with-yankpad company-backends))
#+end_src

** Previewing before undoing; ~undo-propose~

The ~undo-propose~ package is a fairly minimal addition to
the builtin undo features of Emacs
(which can be confusing, but are very powerful,
 since undo-ing is an action which can be undone.)
What ~undo-propose~ does is open a new, read-only buffer
in which the undoing is to be done
(~undo~ and ~undo-only~ are wrapped so as to be allowed,
 although the buffer is read-only.)
It provides commands to
- overwrite the original buffer,
  - either as a single (squashed) action (~C-c C-s~),
  - or as the chain of undo actions performed (~C-c C-c~),
- run a diff against the original buffer (~C-c C-d~), or
- be discarded entirely (~C-c C-k~.)
#+begin_src emacs-lisp
(use-package undo-propose)
#+end_src

In the past, I have used ~undo-tree~ to visualise
the changes to a file as a tree,
allowing movement up and down branches as a local sort
of version control.
But the actual visualisation can sometimes cause lag,
and ~undo-tree~ has been known to cause corruptions
when undoing/redoing (though I have not experienced this personally.)
For the moment, I will stick to the builtin undo behaviour,
with ~undo-propose~ to help visualise the changes.

* Final cosmetics

** The modeline

*** Use the Spacemacs modeline

While I don't use Spacemacs, I do like it's sleek modeline.
#+begin_src emacs-lisp
(use-package spaceline)
#+end_src

Using ~spaceline-emacs-theme~ instead
of ~spaceline-spacemacs-theme~ is supposed to improve compatibility.
#+begin_src emacs-lisp
(spaceline-emacs-theme)
#+end_src

**** Information to display

:TODO:

**** Colour the modeline

This setting changes the colour of the start of the modeline
when the file has been modified and not saved,
a nice subtle reminder to save.
#+begin_src emacs-lisp
(setq spaceline-highlight-face-func
  'spaceline-highlight-face-modified)
#+end_src

In fact, let's make that colouring constant across themes.
#+begin_src emacs-lisp
(custom-theme-set-faces
 'user
 ;; The active buffer has a fairly vibrant blue modeline
 '(mode-line         ((t (:foreground "black"
                          :background "DeepSkyBlue1"))))
 '(powerline-active0 ((t (:foreground "black"
                          :background "DeepSkyBlue2"))))
 '(powerline-active1 ((t (:foreground "black"
                          :background "DeepSkyBlue3"))))
 '(powerline-active2 ((t (:foreground "black"
                             :background "DeepSkyBlue4"))))

 ;; The inactive buffers have less vibrant gray/blue modelines
 '(mode-line-inactive  ((t (:foreground "black"
                            :background "LightSkyBlue1"))))
 '(powerline-inactive0 ((t (:foreground "black"
                            :background "LightSkyBlue2"))))
 '(powerline-inactive1 ((t (:foreground "black"
                            :background "LightSkyBlue3"))))
 '(powerline-inactive2 ((t (:foreground "black"
                             :background "LightSkyBlue4"))))

 ;; Highlighting based on save status of buffer
 '(spaceline-unmodified ((t (:foreground "black"
                             :background "green1"))))
 '(spaceline-modified   ((t (:foreground "black"
                             :background "gold1"))))
 '(spaceline-read-only  ((t (:foreground "black"
                             :background "seashell1")))))
(powerline-reset)
#+end_src

**** Flash on error

The doom themes package comes with a function to make
the mode line flash on error.
#+begin_src emacs-lisp
(require 'doom-themes-ext-visual-bell)
(doom-themes-visual-bell-config)
#+end_src
I'd previously just used ~visible-bell~, but it's a bit nosier
than necessary.

**** Diminish minor mode names

I use a lot of minor modes, so the mode list takes up a lot
of space on the mode line.

~diminish~ alleviates this by allowing us to hide modes
or give them shorter names.
#+begin_src emacs-lisp
(use-package diminish)
#+end_src

I don't need to see that these modes are active.
#+begin_src emacs-lisp
(eval-after-load "yas-minor-mode" '(diminish 'yas-minor-mode))
(eval-after-load "yasnippet" '(diminish 'yas-minor-mode))
(eval-after-load "undo-tree" '(diminish 'undo-tree-mode))
(eval-after-load "which-key" '(diminish 'which-key-mode))
(eval-after-load "org-indent" '(diminish 'org-indent-mode))
#+end_src
:TODO: Add more modes to diminish, consider giving some briefer names instead.q

If later I want to rename modes, just add a string argument
to the above form with a (presumably shorter) name.

** Kill the open init buffer and reopen it

To ensure all these cosmetic changes are picked up,
kill my init buffer that we opened earlier and reopen it.
#+begin_src emacs-lisp
(kill-buffer "emacs-init.org")
(find-file my/emacs-init-file)
#+end_src

* Final modes and final mode settings

** Org mode

*** Speed keys

Speed keys are single keystrokes which execute commands in an
~org~ file when the cursor is at the start of a headline.
They are particularly useful for quickly moving a headline around,
or promoting/demoting a headline (and all children headlines accordingly.)
#+begin_src emacs-lisp
(setq org-use-speed-commands t)
#+end_src

To see the commands available, execute
#+begin_example emacs-lisp
(org-speed-command-help)
#+end_example

*** Automatic tables of contents

This package provides automatic maintainance of a table of contents
under any heading which is labelled with the ~:TOC:~ tag.
#+begin_src emacs-lisp
(use-package toc-org
  ;; Automatically update toc when saving an Org file.
  :hook (org-mode . toc-org-mode))
#+end_src

*** Custom TODO keywords

These words, when appearing at the start of a headline,
mark that headline as a TODO task in the appropriate state.
I've added =SOON=, =NEXT=, =WORKING=, =DELEGATED= and =CANCELLED=.
#+begin_src emacs-lisp
(setq org-todo-keywords
  '((sequence "TODO" "SOON" "NEXT" "WORKING" "|" "DELEGATED" "CANCELLED" "DONE")))
#+end_src

*** Allow alphabetical lists

While not frequently that useful, it is nice to be allowed
to label list items alphabetically.
Note that the labels used in the plaintext Org do not affect the labels
used in most export formats (at least HTML and LaTeX.)
#+begin_src emacs-lisp
(setq org-list-allow-alphabetical t)
#+end_src

*** Reveal hidden elements if they are edited

Folding a document raises the possibility of accidentally editing
hidden portions. Org provides a way to defend against this:
On making an “invisible” edit, the hidden portion will be unfolded
so the edit can be seen.

#+begin_src emacs-lisp
(setq org-catch-invisible-edits 'show)
#+end_src

** Ediff

By default, when using the GUI, Ediff opens a new frame for
the controls for the Ediff session.
I typically use Emacs in fullscreen, and this additional frame
is usually unwelcome. Instead, use a window in the current frame.
#+begin_src emacs-lisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

I prefer to see the files being compared side by side,
rather than split vertically.
#+begin_src emacs-lisp
(setq ediff-split-window-function 'split-window-horizontally)
#+end_src

** Purescript

#+begin_src emacs-lisp
(use-package purescript-mode)
#+end_src

* Session setup

:TODO:

* Cleanup

** Check the contents of ~~/.emacs~

It is not uncommon for ~~/.emacs~ to be modified without my direct action;
either because of some setting change I consent to without thinking about it,
or some well-meaning process making a change I presumably want.

It is for that reason that this file is not directly tangled to ~~/.emacs~.
Erasing those changes by re-writing the content of that file every time I start Emacs
is probably not what I actually want.

That said, I should be made aware of the fact that a change has been made;
either I will want to just undo the settings, or more likely, I will want
to migrate them to their proper place in this file.

Using the copy of the expected ~.emacs~ content which is tangled to ~/tmp/.emacs~ above,
this code checks the contents of ~~/.emacs~. If it is not as expected, show a popup message
and then displays a diff buffer to alert me to the changes.
#+begin_src emacs-lisp :noweb yes :results raw
(let* ((dotemacs-file "~/.emacs")
       (dotemacs-backup "/tmp/.emacs")
       (dotemacs-contents
        (with-temp-buffer
          (insert-file-contents dotemacs-file)
          (buffer-string)))
       (dotemacs-expected
        (with-temp-buffer
          (insert-file-contents dotemacs-backup)
          (buffer-string))))
  (unless (equal dotemacs-contents dotemacs-expected)
    (message-box ".emacs content has been modified from my expected contents!\n\nOpening a diff buffer.")
    (diff dotemacs-file dotemacs-backup)))
#+end_src

Some notes about this:
- I initially attempted to accomplish this comparison by somehow
  comparing the text of the ~~/.emacs~ file to the text of the
  ~src~ block above directly, avoiding the need to tangle that block to ~/tmp~.
  Unfortunately, I couldn't find a satisfying way to obtain the text
  of the ~src~ block in this file as a string.
  - Copying it manually raises issues if it ever changes, of course.
  - I could use noweb syntax to place its contents into this ~src~ block,
    but I could not make it a string, as it contains double quotes,
    and Emacs lacks a form for string literals.
    - I could convert it to a string using the ~string~ function,
      but then comments would be lost. I followed this line briefly anyway,
      trying to read in the contents of ~.emacs~ as Elisp code,
      and then compare the code instead of comparing strings.
      This gets a bit too complicated though and makes
      the difference reporting less satisfying, as it cannot show
      the actual file contents.

** Update the ~README~ file

:TODO:

** Prompt before quitting Emacs

It's rare that I actually want to close Emacs, so it's not an annoyance
to prompt first; in fact, it's much preferred to accidentally closing.
#+begin_src emacs-lisp
(setq confirm-kill-emacs 'yes-or-no-p)
#+end_src
Note that the prompt is skipped if we already have a “do ~x~ before exiting?”
prompt, such as for saving some files.

This is the very last setting, because if we don't make it this far,
I want to be able to fix the error that stopped us reaching here
and quit without being hassled.
